<!--
Todo-List


TODO don't forget to put back begin date to real first day
TODO leave a few seconds to load the data (data does not appear if you scroll immediately)



DONE write viz description for tooltip
DONE hide/show PA comments
DONE add end_comment 'why did this PA end?' to PAs
DONE onclick country display a 2nd section 'past conflicts' to see the past PAs
DONE information window to explain the viz
DONE UN logo on the map
DONE white background on UN logo?
DONE onmouseover conflict highlight country on map
DONE onmouseover conflict circle, can also select country (this helps for small countries)
DONE static infocell header
DONE different color/icon for UN peace treaties (on the map and on the infopanel, and add a UN logo on the PA cells)
DONE onclick a country, show icons showing the number of active/broken PAs so far
DONE PA border color red if PA is broken, blue if active, grey if not active yet
DONE add PAs descriptions
DONE replace Jan 2099 by 'today'
DONE add only one cell "show PAs..." per conflict if there are PAs and onclick this cell, expand it to show all the PAs
DONE import and display peace treaties
DONE add infocell header
DONE onclick country: filter the events and display only the events of this country
DONE fix the way conflicts are displayed in the info panel: Some are displayed more than once
DONE scrollable div
DONE info pannel on the right
DONE onmouseover -> display name popup
DONE Borders should be still visible when green/red contries

wontdos
TODO add legend on top of the map for icon/circle + color meaning (wontdo, infopanel is enough)
TODO don't dispaly PAs for past conflicts? Yes because we can see if there is stability in the region
TODO timeline on the bottom
TODO color switch smooth transition
TODO extra: double click -> show induvidual events inside country
TODO extra: zoom

Ideas
Put PAs in the conflict box and onclick expand and show infos about PA
Circles for PAs: deacreasing radius over time
path animation on selected country

Issues:
* for the moment, I plot a blue circle if at least one PA is active in the country
* that's not okay because in some countries an old PA that's active forever keeps the blue dot
* but since then there has been other conflicts in the country.

* solution: either set the enddate of an infinite peace treaty to the end on the conflict
* or always display the most recent peace treaty
* or display each and every treaty with a small blue/red cross with a random offset from the center

________________________________________________________________

PAs Data Structure

PeaceAgreementsById: store all PAs in a dict (key: PAID or CID)
PeaceAgreementsByCountry: store for each countryID the 


solution 1:
* store PAs by PAID
* each conflict has a list of PAIDs
* + easy to get PAs from conflicts (info pannel)
* - to get by country: get country's CIDs, then for each CID get the PAIDs

solution 2:
* store PAs by PAID
* for each region store a list of PAIDs 

solution 3:
* do both
-->

<!doctype html>
<html>
<head>
    <style type="text/css">

        ul{
            padding: 0;
            margin: 0;
        }

        body{
            /*background-color: grey;*/
            /*background-color: #C9C4BD;*/
            font-family: "Verdana", sans-serif;
            color: rgb(10, 10, 10);
            margin: 0;
        }

        #container{
            position: relative;
            overflow: auto;
            width: 100%;
            height:100%;
        }

        #mapContainer{
            position: fixed;
            float: left;
            left: 0px;
            right: 0px;
            top: 0px;
            bottom: 0px;
            background-color: transparent;
            width: 70%;
            height: 100%;
        }
        #infoContainer{
            float: right;
            width: 29.8%;
            /*border-radius: 10px;*/
            background-color: rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .infocell, .infocell_past{
            margin: 10px;
            padding: 5px;
            border-radius: 10px;
            /*background-color: rgba(255, 255, 255, 0.3);*/
            /*background-color: rgb(180, 180, 180);*/
            font-size: 13px;

            border-style: solid;
            border-width: 2px;
            border-color: transparent;
        }

        .cell_pa{
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            margin: 1px;
            margin-bottom: 5px;
            margin-top: 5px;
            padding: 15px;
            padding-bottom: 10px;
            font-size:12px;
            border-width: 1px;
            /*border-color: rgb(0, 0, 255);*/
            border-style: solid;
        }

        .cell_pa_un{
            background-image: url(data/un_logo.png);
            background-repeat: no-repeat;
            background-position: 98% 8px;
            background-size: 60px;
        }

        #infocell-header{
            white-space:nowrap;
            padding-top: 25px;
            margin-bottom: 30px;
            margin-left: 10px;
            position: sticky;
            top: 0;
            z-index: 2;
        }

        #filter-header{
            border-style: solid;
            border-width: 2px;
            border-color: rgb(70, 70, 70);
            border-radius: 10px;
            text-align: center;

            padding: 10px;
            padding-top: 15px;
            padding-bottom: 15px;
            
            /*background-color: rgba(255, 255, 255, 0.3);*/
            background-color: rgb(180, 180, 180);
            font-size: 14px;
        }

        #dateContainer{
            white-space:nowrap;
            /*height:50px;*/
            text-align:center;
            /*line-height: 50px;*/
            /*display: block;*/

            /*background-color: rgba(255, 255, 255, 0.3);*/
            background-color: rgb(180, 180, 180);
            font-size: 14px;
            border-radius: 10px;
            border-color: rgb(70, 70, 70);
            border-style: solid;
            border-width: 2px;

            margin-left: auto;
            margin-right: 10px;
            
            padding: 10px;
            padding-top: 15px;
            padding-bottom: 15px;
        }

        #month{
            width: 30px;
            display: inline-block;
        }

        path {
            stroke: rgb(200, 200, 200);
            stroke-width: 0.5px;
            stroke-linejoin: bevel;
            fill: #A5A19B;
        }

        .circles{
            stroke: blue;
            fill: transparent; 
            stroke-width: 2px;
        }

        .show_pa{
            text-align: center;
        }

        .pa_logo{
            float: right;
            width:18px;
        }

        .infodiv{
            padding-left: 8px;
            padding-top: 3px;
            position: absolute;
            color:#6E6B68;
        }

        .tooltip{  
            position: absolute;         
            text-align: left;         
            width: 850px;                 
            padding: 20px;               
            font: 12px sans-serif;      
            background: rgba(255, 255, 255, 0.8); 
            border: 0px;        
            border-radius: 10px;         
            pointer-events: none;
        }

        #filter-header, #dateContainer, .infocell, .infocell_past{
            background-color: #A5A19B;
        }

        #title{
            font-size: 35px;
            color: rgb(80, 80, 80);
            text-align: center;
            vertical-align: center;
            position: absolute;
            width: 60%;
            top: 20%;
            left: 20%;
            z-index: 2;
            border: 0px;
            border-top: 8px;
            border-bottom: 8px;
            border-style: solid;
            opacity: 0;
        }

        #storylink{
            padding-left: 60px;
            padding-top: 1px;
            position: absolute;
            color:#6E6B68;
        }

        div#instructions{
            text-align: center;
            background-color: #C9C4BD;
            border-color: #6E6B68;
            color: #5C5A56;
            border-style: solid;
            border-width: 2px;
            border-radius: 10px;
            padding: 20px;
            padding-bottom: 0px;
        }

        /*div.colorBox{
            width: 20px;
            height: 10px;
        }

        div#legendBox{
            height: 100px;
        }*/

    </style>
    <script src="https://d3js.org/d3.v4.min.js"> </script>
    <script src="//d3js.org/topojson.v1.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <meta charset="UTF-8">
</head>
<body>
    <div id='container'>
        <!--<div id='legendBox'></div>-->
        <div id='title'></div>
        <div id='infoContainer'>
            <div id='infocell-header'>
                <span id='filter-header'></span>
                <span id='dateContainer'>
                    <span id='month'></span>
                    <span id='year'></span>
                </span>
            </div>
        </div>
        <div id='mapContainer'>
            <a id='storylink' href='https://rbsteinm.github.io/AppliedDataAnalysis/project/frontend/datastory.html' title='Tell me a story !'>
                <i style="font-size: 40px;" class="fa fa-comment-o" aria-hidden="true"></i>
            </a>
        </div>
    </div>
</body>
<script type="text/javascript">

    // ___________________________________________ GLOBAL VARIABLES ___________________________________________


    const MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const PATH_TO_MAP = './data/countries.geo.json';
    const SMALL_STEP_SIZE = 30; // represents the speed of the slider
    const BIG_STEP_SIZE = 365;
    const START_DATE = new Date("1970-01-01");
    //const START_DATE = new Date("1991-05-01"); // debug
    const END_DATE = new Date("2016-12-01");
    let current_date = START_DATE;
    let mapContainer = d3.select("#mapContainer");
    let infoContainer = d3.select('#infoContainer');
    let countries;
    let conflicts = {}; // all conflicts, sorted by location id
    let conflicts_by_id = {}; // all conflicts, sorted by conflict id
    let agreements_by_loc = {};
    let agreements_by_id = {};
    let width = mapContainer.node().clientWidth;
    let height = mapContainer.node().clientHeight;
    let margin = 8;
    let selected_country_id = null;
    let moved = false;

    //colors
    const MAP_STROKE_HL_COLOR = 'rgb(255, 255, 255)';
    const MAP_STROKE_COLOR = '#C9C4BD';

    const ACTIVE_PA_COLOR = 'rgb(0, 0, 255)';
    const BROKEN_PA_COLOR = 'rgb(255, 0, 0)';
    const FORTH_PA_COLOR = 'rgba(0, 0, 0, 0.5)'

    const CELL_BORDER_COLOR = 'rgb(70, 70, 70)';
    const UN_COLOR = 'rgb(91, 146, 229)';

    const COLOR_A = '#C9C4BD';
    const COLOR_B = '#A5A19B';
    const COLOR_C = '#938F8A';
    const COLOR_D = '#6E6B68';
    const COLOR_E = '#5C5A56';


    // ___________________________________________ DOM ELEMENTS ___________________________________________

    d3.select('body').style('background-color', COLOR_A);



    infoContainer
        .style('height', height+'px')
        .style('background-color', 'transparent')
        .style('border-left', 'solid 1px ' + COLOR_B);
        /*.style('border-style', 'solid')
        .style('border-width', '1px')
        .style('border-color', COLOR_C);*/

    // add infocell header
    infoContainer
    .select('#filter-header')
        .html(d => infoHeaderToString())
        .style('opacity', 0)
        .transition()
        .style('opacity', 1);


    // ___________________________________________ IMPORT DATA ___________________________________________

    // Conflicts data
    d3.tsv("./data/conflicts.csv")
    .row(function(d) {
        var startdatesplit = d.startdate.split('-');
        var startdate = new Date(parseInt(startdatesplit[0]), parseInt(startdatesplit[1])-1, parseInt(startdatesplit[2]));
        var enddatesplit = d.enddate.split('-');
        var enddate = new Date(parseInt(enddatesplit[0]), parseInt(enddatesplit[1])-1, parseInt(enddatesplit[2]));
        // split locations, in case there are several locations for a single conflict
        d.locationID.split(',').forEach(function(loc_id){
            // create the dict entry if it does not exist yet
            if(!conflicts[loc_id]) conflicts[loc_id] = [];
            // push the data in the dict
            conflicts[loc_id].push({'start':startdate, 'end':enddate, 'locations':d.location, 'conflict_id':d.conflictid, 'sidea':d.sidea, 'sideb':d.sideb});
        });

        conflicts_by_id[d.conflictid] = {'locations':d.location, 'sidea':d.sidea, 'sideb':d.sideb, 'start':startdate, 'end':enddate, 'locationIDs':d.locationID.split(',')};
    })
    .get(function(err, rows) {
        if (err) return console.error(err);
        initBrowserCheck();
    });

    // Peace Agreements data
    d3.tsv("./data/peace_agreements.csv")
        .row(function(row){
            var startdatesplit = row.pa_date.split('-');
            var startdate = new Date(parseInt(startdatesplit[0]), parseInt(startdatesplit[1])-1, parseInt(startdatesplit[2]));
            var enddatesplit = row.enddate.split('-');
            var enddate = new Date(parseInt(enddatesplit[0]), parseInt(enddatesplit[1])-1, parseInt(enddatesplit[2]));
            let un = row.UN == '0'? false : true;
            // store PAs by PAIDs
            agreements_by_id[row.PAID] = {'name':row.pa_name, 'start':startdate, 'end':enddate, 'comment':row.pa_comment, 'end_comment':row.c_duration, 'link':row.link, 'locationID':row.locationID, 'cid':row.CID, 'UN': un};
            // store PAIDs by location
            row.locationID.split(',').forEach(function(loc_id){
                // create the dict entry if it does not exist yet
                if(!agreements_by_loc[loc_id]) agreements_by_loc[loc_id] = [];
                // push the data in the dict
                agreements_by_loc[loc_id].push(row.PAID);
            });
            // store an array of its PAIDs in each conflict
            if(!conflicts_by_id[row.CID]['PAIDs']) conflicts_by_id[row.CID]['PAIDs'] = [];
            conflicts_by_id[row.CID]['PAIDs'].push(row.PAID);

        })
        .get(function(err, rows) {
            if (err) return console.error(err);
        });


    // ___________________________________________ MAP DISPLAY ___________________________________________


    let svg = mapContainer.append('svg')
        .attr('width', width)
        .attr('height', height)
        .on('click', function(d){
            selected_country_id = null;
            // remove all past conflicts cells
            infoContainer.selectAll('.infocell_past').remove();
            updateMapAndInfo();
            updateInfoHeader();
        });

    let mapLayer = svg.append('g');

    let centroids = {};

    function displayMap(){
        // projection of the world map
        var projection = d3.geoMercator().scale(width / 2 / Math.PI).translate([width/2, height/2+160]);
        let path = d3.geoPath().projection(projection);
        
        d3.json(PATH_TO_MAP, function(err, geojson) {

            countries = mapLayer.selectAll("path")
            .data(geojson.features)
            .enter().append("path")
            .attr("d", path)
            .attr('id', country => country.id)
            .attr('name', country => country.properties.name)
            .on('mouseover', function(d,i){
                d3.select(this).style('stroke', MAP_STROKE_HL_COLOR);
                d3.select(this).style('stroke-width', 2);
            })
            .on('mouseout', function(d, i){
                d3.select(this).style('stroke', MAP_STROKE_COLOR);
                d3.select(this).style('stroke-width', 0.5);
            })
            .on('click', function(d){
                selected_country_id = d.id;
                updateMapAndInfo();
                updateInfoHeader(d.properties.name);
                d3.event.stopPropagation();
            })
            .append('svg:title').text(function(d, i){return d.properties.name});

            var features = geojson.features;
            features.map(function(f){
                return {'path':path.centroid(f), 'id':f.id};
            }).forEach(c => centroids[c.id] = c.path);
        });
    }




    // ___________________________________________ UPDATE MAP ___________________________________________

    
    function initBrowserCheck(){
        if (!(!!window.chrome && !!window.chrome.webstore)){
            mapContainer.style('opacity', 0);
            infoContainer.style('opacity', 0);
            d3.select('#title')
                .attr('height', height).attr('width', width).html(browserCheckToString())
                .style('opacity', 0)
                .transition().delay(700).duration(1000).style('opacity', 0.7);
            console.log('not chrome')
            return false;
        }
        else{
            init();
        }
    }

    function browserCheckToString(){
        let res = "<br/>We highly recommend using Google Chrome for a smoother experience !<br/><br/>";
        res += "<span style='font-size: 12px;' onclick='init();' onmouseout='this.style.textDecoration=`none`;'  onmouseover='this.style.textDecoration=`underline`;'>I don't care, take me to the viz (not recommended)</span><br/>";
        return res;
    }


    function init(){

        displayMap();
        printInfoIcon();

        // scrolling control for Chrome
        svg.node().addEventListener("mousewheel", function(e){
            if(!moved){
                console.log('remove instructions bubble');
                moved = true;
                removeInstructionsBubble();
            }
            onScrollEvent(e.wheelDelta < 0, SMALL_STEP_SIZE)
        }, false);

        svg.node().addEventListener('DOMMouseScroll', function(e){
            if(!moved){
                console.log('remove instructions bubble');
                moved = true;
                removeInstructionsBubble();
            }
            var delta = e.wheelDelta ? e.wheelDelta : -e.detail;
            onScrollEvent(delta < 0, SMALL_STEP_SIZE);
        }, false);

        // arrow keys control
        window.onkeydown = function(e) {
           var key = e.keyCode ? e.keyCode : e.which;

            if(!moved &&(key == 37 || key == 39)){
                console.log('remove instructions bubble');
                moved = true;
                removeInstructionsBubble();
            }

           // left arrow
           if (key == 37) onScrollEvent(false, SMALL_STEP_SIZE);
           // right arrow
           else if (key == 39) onScrollEvent(true, SMALL_STEP_SIZE);
        }

        // TODO put animation back
        d3.select('#title')
            .attr('height', height).html(titleToString())
            .style('opacity', 0)
            .transition().delay(700).duration(1000).style('opacity', 0.7)
            .transition().delay(1500).duration(1000).style('opacity', 0).remove();

        mapContainer.style('opacity', 0).transition().delay(4000).duration(1500).style('opacity', 1);
        infoContainer.style('opacity', 0).transition().delay(5000).duration(2500).style('opacity', 1);
        d3.select('.infodiv').style('opacity', 0).transition().delay(4000).duration(1500).style('opacity', 1);

        printInstructionsBubble(7000);

        printDate(current_date);
        //updateMapAndInfo();
    }

    function titleToString(){
        return '<span style="font-size:70px;">What is the impact of the United Nations over armed conflicts resolution?</span><br/><br/><br/><span style="font-size:30px;">An interactive map</span><br/><br/>';
    }

    function instructionsToString(){
        return 'Use the <i class="fa fa-arrow-left" aria-hidden="true"> </i> <i class="fa fa-arrow-right" aria-hidden="true"></i> arrow keys or scroll your mouse wheel to navigate through time<br/><br/>';
    }


    // This function is called at each mouseWheelEvent
    // direction: true if scroll forward, false if backwards
    function onScrollEvent(direction, step){
        // update the current date
        updateDate(direction, step);
        printDate(current_date);
        // update the countries' colors
        updateMapAndInfo();
    }

    // updates the respective color of each country on the map
    // and the info panel on the right
    function updateMapAndInfo(){
        let ongoingConflits = new Set();
        let pastConflicts = new Set();
        let locsWithPA = new Set();
        let locsWithUNPA = new Set();
        Object.keys(conflicts).forEach(function(loc_id){
            let status = getConflictStatus(current_date, loc_id);
            let color = getColor(status.status, status.duration);
            // fill the country with the appropriate color
            mapLayer.select('path#'+loc_id).style('fill', color);
            // Fill the array of ongoing conflicts for the info pannel
            if(selected_country_id == null || loc_id == selected_country_id){
                status.ongoingConflits.forEach(conflict => ongoingConflits.add(conflict));
            }
            // only add past conflicts if a location is selected
            if(loc_id == selected_country_id && selected_country_id != null){
                status.pastConflicts.forEach(cid => pastConflicts.add(cid));
            }
            // Store each location that has at least one active PA
            if(agreements_by_loc[loc_id]){
                paStatus = locPaStatus(current_date, loc_id);
                if(paStatus.ongoingPA){
                    if(paStatus.is_un){
                        locsWithUNPA.add(loc_id);
                    }
                    else{
                        locsWithPA.add(loc_id); 
                    }
                }

            }
        });   
        updateInfoPanel(Array.from(ongoingConflits), Array.from(pastConflicts));
        updateInfocells();
        updateAgreementCells();
        updateUNCircles(locsWithUNPA);
        updateCircles(locsWithPA);
    }


    // draw a blue circle at the centroid of each location in the input array
    // the array contains all the locations that have at least one active PA
    // remove circles from other locations
    function updateCircles(loc_ids){
        let circles = svg.selectAll('.circles').data(Array.from(loc_ids), x => x);
        circles.enter()
            .append('circle')
            //.append('image')
            //.attr('xlink:href','data/un_logo.png')
            //.attr('width', '20')
            .on('mouseover', function(d){
                mapContainer.select('path#'+d).style('stroke', MAP_STROKE_HL_COLOR);
                mapContainer.select('path#'+d).style('stroke-width', 2);
            })
            .on('mouseout', function(d){
                mapContainer.select('path#'+d).style('stroke', MAP_STROKE_COLOR);
                mapContainer.select('path#'+d).style('stroke-width', 0.5);
            })
            .on('click', function(d){
                selected_country_id = d;
                updateMapAndInfo();
                updateInfoHeader(mapContainer.select('path#'+d).attr('name'));
                d3.event.stopPropagation();
            })
            //.append('svg:title').text(function(d, i){return 'test'})
            .classed('circles', true)
            .attr('cx', x => centroids[x][0])
            .attr('cy', x => centroids[x][1])
            .attr('id', x => 'circle_' + x)
            .attr('r', 0)
            .transition()
            .attr('r', 6)
            .transition()
            .attr('r', 3);

        circles.append('svg:title').text(function(d, i){return mapContainer.select('path#'+d).attr('name')});

        circles.exit()
            .attr('r', 3)
            .transition()
            .attr('r', 0)
            .remove();
    }

    // same as UpdateCircles() but draws UN logos instead of circles
    function updateUNCircles(loc_ids){
        let circles = svg.selectAll('.un_circles').data(Array.from(loc_ids), x => x);
        let icon_width = 12;
        let test = circles.enter()
            .append('image')
            .attr('xlink:href','data/un_bg.png')
            .on('mouseover', function(d){
                mapContainer.select('path#'+d).style('stroke', MAP_STROKE_HL_COLOR);
                mapContainer.select('path#'+d).style('stroke-width', 2);
            })
            .on('mouseout', function(d){
                mapContainer.select('path#'+d).style('stroke', MAP_STROKE_COLOR);
                mapContainer.select('path#'+d).style('stroke-width', 0.5);
            })
            .on('click', function(d){
                selected_country_id = d;
                updateMapAndInfo();
                updateInfoHeader(mapContainer.select('path#'+d).attr('name'));
                d3.event.stopPropagation();
            })
            .attr('class', 'un_circles')
            .attr('x', x => centroids[x][0]-icon_width/2)
            .attr('y', x => centroids[x][1]-icon_width/2)
            .attr('id', x => 'circle_' + x)
            .attr('height', 0)
            .attr('width', 0)
            .transition()
            .attr('height', 30)
            .attr('width', 30)
            .transition()
            .attr('height', icon_width)
            .attr('width', icon_width)
            
            circles.append('svg:title').html(function(d, i){return mapContainer.select('path#'+d).attr('name') + ' - UN intervention'}); // continue here

        circles.exit()
            .attr('height', icon_width)
            .attr('width', icon_width)
            .transition()
            .attr('height', 0)
            .attr('width', 0)
            .remove();
    }
    // ___________________________________________ INFO PANEL ___________________________________________


    // This method is called on each scroll event to append new conficts 
    // and remove finished conflicts
    function updateInfoPanel(ongoing_cids, past_cids){
        appendInfocells(ongoing_cids, false);
        if(selected_country_id != null){
            appendInfocells(past_cids, true);
        }
        
    }

    // this methods appends a cell in the info_panel for each c_id in the input list
    // is_past is a boolean used to differentiate list of ongoing conflicts from list of past conflicts
    function appendInfocells(conflict_ids, is_past){
        let cell_class = is_past ? 'infocell_past' : 'infocell';
        let cells = d3.select('div#infoContainer').selectAll('.'+cell_class).data(conflict_ids, cft_id => cft_id);
        
        cells.exit()
            .remove();
        
        cells.enter()
            .append('div')
            .attr('class', cell_class)
            .attr('id', cid => 'infocell_' + cid)
            .attr('cid', cid => cid)
            .attr('open', '0')
            .on('click', function(d){showHideAgreements(d)})
            .on('mouseover', function(d){
                d3.select(this).style('border-color', CELL_BORDER_COLOR);
                if(hasAgreements(d)) d3.select(this).select('.show_pa').select('i').style('opacity', '1');
                //highlight the locations of the conflict on the map
                conflicts_by_id[d].locationIDs.forEach(function(loc){
                    mapContainer.select('path#'+loc).style('stroke', MAP_STROKE_HL_COLOR);
                    mapContainer.select('path#'+loc).style('stroke-width', 2); 
                });
            })
            .on('mouseout', function(d){
                d3.select(this).style('border-color', 'transparent');
                d3.select(this).select('.show_pa').select('i').style('opacity', '0.5');
                //highlight the locations of the conflict on the map
                conflicts_by_id[d].locationIDs.forEach(function(loc){
                    mapContainer.select('path#'+loc).style('stroke', MAP_STROKE_COLOR);
                    mapContainer.select('path#'+loc).style('stroke-width', 0.5);
                });
            })
            .html(cid => conflictToString(cid, is_past) + closedConflictToString(hasAgreements(cid)))
            .style('opacity', 0)
            .transition()
            .style('opacity', 1);
    }

    // updates in each infocell the number of active/broken PAs
    function updateInfocells(){
        infoContainer.selectAll('.infocell, .infocell_past').each(function(d){
            let cell = d3.select(this);
            let cid = cell.attr('cid');
            let pa_sums = getAgreementsSums(cid, current_date);
            cell.select('.pa_sums').html(paSumsToString(pa_sums));
        });
    }

    // returns html code to fill the header of the infocells
    function infoHeaderToString(locationName=null){
        let res;
        if(locationName){
            let locName = locationName.length > 20 ? selected_country_id : locationName;
            res = "Conflicts in <strong>" + locName + "</strong>";
        }
        else{
            res = '<i style="opacity:0.5;">Click on any country to select it</i>';
        }

        return res;
    }

    function updateInfoHeader(locationName=null){
        infoContainer.select('#filter-header').html(infoHeaderToString(locationName));
    }

    // this function is called when a conflict cell in the infopanel is clicked
    // it shows/hides the 
    function showHideAgreements(cid){
        if(!conflicts_by_id[cid].PAIDs){
            console.log("no PAs")
            return;
        }
        let cell = d3.select('#infocell_'+cid);
        if(cell.attr('open') == '0'){
            cell.attr('open', '1')
            .append('div')
                .attr('class', 'pas_container')
                .html(agreementsToString(cid))
                .style('opacity', 0)
                .transition()
                .style('opacity', 1);
            cell.select('.show_pa').remove();
            cell.append('div').html("<div class=show_pa><i style='opacity:0.5'>Click on the cell to hide the peace agreements ...</i></div>");
        }
        else{
            cell.attr('open', '0')
                .select('.pas_container')
                .remove();
            cell.select('.show_pa').remove();
            cell.append('div').html(closedConflictToString(true));
        }
    }


    // ___________________________________________ CONFLICTS METHODS ___________________________________________


    // returns a string decribing the conflict for the infopanel
    function conflictToString(c_id, is_past){
        let c = conflicts_by_id[c_id];
        let res = "";
        let pas_sums = getAgreementsSums(c_id, current_date);
        //res += "<div style='text-align:center'><i style='opacity:0.5'>Conflict #" + c_id + "</i></div>";
        res += "<div style='text-align:right'><span style='opacity:0.5; font-size: 10px'>Conflict #" + c_id + "</span></div>";
        // active/broken PAs count
        res += "Location: " + c.locations;
        res += is_past ? '<br/>Conflict status: <span style="color:green;">resolved</span>' : '<br/>Conflict status: <span style="color:red;">active</span>';
        res += "<br/>Duration: " + dateToString(c.start) + " - " + dateToString(c.end);
        res += "<br/>Side A: " + c.sidea + "<br/>Side B: " + c.sideb;
        if(pas_sums){
            res += "<span class='pa_sums'>";
            res += paSumsToString(pas_sums);
            res += "</span>";
        }
        return res;
    }

    // returns true if there is at least one conflict in the country, false otherwise
    function isInConflict(date, country){
        return conflicts[country].some(conflict => (date > conflict.start && date < conflict.end));
    }

    // This function returns the status of the country at the given date
    // and for how long this status has been lasting
    // it also returns an array containing the ongoing conflicts
    // true: conflict, false: no conflict (i.e. peace)
    // country: country id
    function getConflictStatus(current_date, country){
        let ongoingConflits = conflicts[country].filter(c => (current_date > c.start && current_date < c.end));
        let pastConflicts = conflicts[country].filter(c => (c.end >= START_DATE && current_date > c.start && current_date >= c.end));
        let status, duration;

        // The country is at peace
        if(ongoingConflits.length == 0){
            status = false;
            let latestPeaceDay = d3.max([START_DATE, d3.max(conflicts[country].map(c => c.end).filter(end => end < current_date))]);
            duration = msToDays(current_date - latestPeaceDay);
        }
        // Only one conflict in the country at that time
        else if(ongoingConflits.length == 1){
            status = true;
            duration = msToDays(current_date - ongoingConflits[0].start);
        }
        // more than one conflict at that time
        else{
            status = true;
            duration = msToDays(current_date - d3.min(ongoingConflits, c => c.start));
        }
        return {'status': status, 'duration':duration, 'ongoingConflits':ongoingConflits.map(c => c.conflict_id), 'pastConflicts':pastConflicts.map(c => c.conflict_id)};
    }

    // returns the corresponding color (red for conflict, green for peace)
    // the duration determines the intensity (saturation) of the color
    // status: boolean indicating wether there is a conflict of not
    // duration: for how long has this status been lasting?
    function getColor(status, duration){
        let hue = status ? 360 : 100;
        let scale = d3.scaleLinear().domain([0, 5000]).range([0.3, 1]).clamp(true);
        let saturation = scale(duration);

        let color = d3.hsl(hue, saturation, 0.5);
        return color.rgb();
    }

    // returns html code containing 'show more' message
    function closedConflictToString(has_pas){
        let text = has_pas ? 'Click on the cell to see the peace agreements ...' : 'No peace agreement for this conflict';
        return "<div class=show_pa><i style='opacity:0.5'>" + text + "</i></div>";
    }


    // ___________________________________________ AGREEMENTS METHODS ___________________________________________



    // returns html code that contains info about how many PAs are active/broken
    function paSumsToString(pa_sums){
        let res = "<div> Active/Broken peace agreements: ";
        // active United Nations PAs
        for(let i = 0; i < pa_sums.activeUn; i++){
            res += '<img src="data/un_logo.png" style="padding-left: 3px; width:20px;">';
        }
        // broken United Nations PAs
        for(let i = 0; i < pa_sums.brokenUn; i++){
            res += '<img src="data/un_logo_cross.png" style="padding-left: 3px; width:20px;">';
        }
        // active Non-UN PAs
        for(let i = 0; i < pa_sums.activeNonUn; i++){
            res += '<i class="test fa fa-check-circle-o" aria-hidden="true" style="text-weight:bold; padding-left: 3px;font-size:16px; color:'+ ACTIVE_PA_COLOR +'"></i>';
        }
        // broken Non-UN PAs
        for(let i = 0; i < pa_sums.brokenNonUn; i++){
            res += '<i class="test fa fa-times-circle-o" aria-hidden="true" style="text-weight:bold; padding-left: 3px;font-size:16px; color:'+ BROKEN_PA_COLOR +'"></i>';
        } 
        res += "</div>";
        return res;
    }

    // if cid has PAs, returns the list of its PAIDs, false otherwise
    function hasAgreements(cid){
        return conflicts_by_id[cid].PAIDs;
    }

    
    // returns html element containing textual representation of all the PAs relative to the input conflict
    function agreementsToString(cid){
        let result = "";
        let paids = conflicts_by_id[cid].PAIDs;
        if(!paids) return result;
        paids.forEach(function(paid){
            result += '<span onclick="event.stopPropagation();openClosePA(this);" open="0">';
            result += closedAgreementToString(paid);
            result += '</span>'
        });
        return result;
    }

    function closedAgreementToString(paid){
        result = "";
        let pa = agreements_by_id[paid];
        let pa_status = getAgreementStatus(pa);
        // put the UN logo if it's a UN treaty
        let cell_class = pa.UN ? 'cell_pa cell_pa_un' : 'cell_pa';
        result += "<div class='" + cell_class + "' paid='" + paid + "' style='border-color: transparent;' onmouseover='agreementCellBorder(this, true);' onmouseout='agreementCellBorder(this, false)'>";
        result += "<div style='text-align:center'><strong><i style='opacity:1'>" + pa.name + "</i></strong></div>";
        let statusString = "<span class='pa_status' style='color: " + pa_status.color + "'><span> (" + pa_status.status + ")</span></span>";
        result += "<br/>Duration: " + dateToString(pa.start) + " - " + dateToString(pa.end) + statusString;
        result += "<br/><br/><div style='text-align: center;'><i style='opacity:0.5'>Click to learn more about this agreement ...</i></div>";
        result += "</div>";
        return result;

    }


    function openedAgreementToString(paid){
        result = "";
        let pa = agreements_by_id[paid];
        let pa_status = getAgreementStatus(pa);
        // put the UN logo if it's a UN treaty
        let cell_class = pa.UN ? 'cell_pa cell_pa_un' : 'cell_pa';
        result += "<div class='" + cell_class + "' paid='" + paid + "' style='border-color: transparent;' onmouseover='agreementCellBorder(this, true);' onmouseout='agreementCellBorder(this, false)'>";
        result += "<div style='text-align:center'><strong><i style='opacity:1'>" + pa.name + "</i></strong></div>";
        let statusString = "<span class='pa_status' style='color: " + pa_status.color + "'><span> (" + pa_status.status + ")</span></span>";
        result += "<br/>Duration: " + dateToString(pa.start) + " - " + dateToString(pa.end) + statusString;
        result += "<br/><br/><i><strong>Description:</i></strong><br/><br/><div style='white-space: pre-line'>" + pa.comment + "</div>";
        if(pa.end_comment != '' &&  pa.end.getFullYear() != 2099){
            result += "<br/><br/><strong><i>Why did this agreement end?</i></strong><br/><br/><div>" + pa.end_comment + "</div>";
        }
        result += "<br/><br/><div style='text-align: center;'><i style='opacity:0.5'>Click the cell to close it</i></div>";
        result += "</div>";
        return result;
    }

    // this function opens/closes a PA when it is clicked
    // input: clicked DOM element (PA cell)
    function openClosePA(cell){
        console.log('open pa');
        //event.stopPropagation();
        let elem = d3.select(cell);
        let open = (elem.attr('open') == '1');
        if(open){
            elem.html(closedAgreementToString(elem.select('div').attr('paid'))); 
            elem.attr('open', '0');
        }
        else{
            elem.html(openedAgreementToString(elem.select('div').attr('paid')));
            elem.attr('open', '1');
        }
    }

    // highlights the input PA cell in the color representing the PA status
    // over: true if mouseover, false if mouseout
    function agreementCellBorder(cell, over){
        if(!over) d3.select(cell).style('border-color', 'transparent');
        else{
            let paid = d3.select(cell).attr('paid');
            let color = getAgreementStatus(agreements_by_id[paid]).color;
            d3.select(cell).style('border-color', color);
        }
    }

    // updates the textual status of the visible PA cells (broken, active, forthcoming)
    function updateAgreementCells(){
        let cells = d3.selectAll('.infocell, .infocell_past').filter(function(d){return d3.select(this).attr('open') == '1';}).selectAll('.cell_pa');
        cells.each(function(d){
            let cell = d3.select(this);
            let pa = agreements_by_id[cell.attr('paid')];
            let pa_status = getAgreementStatus(pa);
            // edit the status text in the cell
            cell.select('span.pa_status').html("<span style='color: " + pa_status.color + "'> (" + pa_status.status + ")</span>");
        });
    }

    // returns a boolean if there's at least one ongoing PA and the list of ongoing PAs
    // returns the same thing for broken PAs
    function locPaStatus(current_date, country_id){
        let ongoingPas = agreements_by_loc[country_id].map(paid => agreements_by_id[paid]).filter(pa => (current_date >= pa.start && current_date < pa.end));
        let ongoingUnPas = ongoingPas.filter(pa => pa.UN);
        return {'ongoingPA': (ongoingPas.length > 0), 'is_un':(ongoingUnPas.length > 0)};
        //let brokenPas = agreements_by_loc[country_id].map(paid => agreements_by_id[paid]).filter(pa => (current_date >= pa.start && current_date >= pa.end));
        //return {'ongoingPA':(ongoingPas.length > 0), 'brokenPA':(brokenPas.length > 0), 'ongoingPas':ongoingPas, 'brokenPas':brokenPas};
    }

    // returns the number of active/broken agreements of the input conflict at the input date
    function getAgreementsSums(cid, date){
        if(!hasAgreements(cid)) return false;
        let pas = conflicts_by_id[cid].PAIDs.map(paid => agreements_by_id[paid]);
        let activePas = pas.filter(pa => (current_date >= pa.start && current_date < pa.end));
        let activeUn = activePas.filter(pa => pa.UN);
        let brokenPas = pas.filter(pa => (current_date >= pa.start && current_date >= pa.end));
        let brokenUn = brokenPas.filter(pa => pa.UN);
        return {'activeNonUn':(activePas.length - activeUn.length), 'brokenNonUn':(brokenPas.length - brokenUn.length), 'activeUn':activeUn.length, 'brokenUn':brokenUn.length};
    }

    // returns the status (forthcoming, broken, active) of the
    // input PA and the corresponding color
    function getAgreementStatus(pa){
        if(pa.start > current_date){
            return {'status': 'Forthcoming', 'color': FORTH_PA_COLOR};
        }
        else if(pa.end <= current_date){
            return {'status': 'Broken', 'color': BROKEN_PA_COLOR};
        }
        else if(pa.start <= current_date && pa.end > current_date){
            return {'status': 'Active', 'color': ACTIVE_PA_COLOR};
        }
        else{
            console.error('Agreement color error, this should not happen');
            return {'status': 'Forthcoming', 'color': FORTH_PA_COLOR};
        }
    }

    // ___________________________________________ DATE PANEL ___________________________________________


    function dateToString(date){
        return date.getFullYear() == 2099 ? 'today' : MONTH_NAMES[date.getMonth()] + " " + date.getFullYear();
    }

    // prints the input date in the date container
    function printDate(date){
        d3.select('#month').html(MONTH_NAMES[date.getMonth()]);
        d3.select('#year').html(date.getFullYear());
    }

    // This void function updates the global 'current_date' variable after a scrollEvent
    // direction: the scroll direction that defines if we go back or forward in time
    function updateDate(direction, stepsize){
        // are we scrolling up or down?
        let step = direction ? stepsize : -stepsize;
        let new_date = d3.timeDay.offset(current_date, step);

        // clamp the date
        if(new_date < START_DATE){
            current_date = START_DATE;
        }
        else if(new_date > END_DATE){
            current_date = END_DATE;
        }
        else{
            current_date = new_date;
        }
    }


    // ___________________________________________ HELPER METHODS ___________________________________________


    // input: a duration in ms
    // output: the same duration in days
    function msToDays(ms){
        return Math.round(ms/(1000*60*60*24));
    }

    // prints an information icon at the top left of the page
    // onmouseover this icon, some info about the viz is displayed
    function printInfoIcon(){
        d3.select('#container')
            .append('div')
            .html( '<i class="infodiv fa fa-info-circle" aria-hidden="true" style="font-size: 40px"></i>')
            .on("mouseover", function(d) {      
                div.transition()        
                    .duration(200)      
                    .style("opacity", 1);      
                div.html(vizInfoToString())  
                    .style("left", '50px')     
                    .style("top", '20px');    
            })                  
            .on("mouseout", function(d) {       
                div.transition()        
                    .duration(500)      
                    .style("opacity", 0);   
            });

        var div = d3.select("#container").append("div")   
            .attr("class", "tooltip")               
            .style("opacity", 0);
    }

    function vizInfoToString(){
        return "<strong><i>What is the pupose of the viz?</i></strong><br/><br/>This viz shows the evolution of armed conflicts around the world and the different peace treaties signed as part of these conflicts, with a particular focus on the United Nations interventions.<br/><br/><strong><i>How does this work?</i></strong><br/><br/>You can simply scroll, or use the left and right arrow keys to navigate through time. The current date is displayed in the top-right corner of your screen. If you want to focus on a particular country, just click it.<br/><br/><strong><i>Armed conflicts?</i></strong><br/><br/>An armed conflict is a contested incompatibility that concerns government and/or territory where the use of armed force between two parties, of which at least one is the government of a state, results in at least 25 battle-related deaths in a calendar year. A country is considered to be in a state of conflict if its government has a primary claim to the issue in dispute.<br/><br/><strong><i>What's with the ugly coloring?</i></strong><br/><br/>Well I'm glad you ask! A country colored in green is at peace, while a red country is currently involved in at least one conflict. Note that it does not necessarily mean that the conflict(s) is/are taking place in the aforementioned country! The longer a country has been at peace/in a state of conflict, the more saturated (i.e. vivid) its color. The color will get stronger and stronger, until it stabilizes at 5000 days (~ 13 years). If a country is neither green nor red, it means there is simply no conflict at all there.<br/><br/><strong><i>And the peace agreements?</i></strong><br/><br/>A blue circle displayed on a country means that at least one peace agreement involving this country is active. If the circle turns into a white icon (which is actually the United Nations' logo, but you can't see it because it's too small/thin/light (blame them, not me)), it means that the United Nations was involved in at least one treaty that concerns this country and is still active at the current date.<br/><br/><strong><i>What about the panel on the right?</i></strong><br/><br/>By default, it shows all the active conflicts worldwide. When you click a country, it will show the currently active but also the past (resolved) conflicts involving this country's government. Clicking a conflict will display all the peace agreements signed in the scope of this conflict (if any). You can also click any agreement to learn more about it. A UN logo in the top-right corner of an agreement's cell means that the United Nations were involved in its conclusion.<br/><br/><strong><i>Where did you get all this data?</i></strong><br/><br/>The data comes from the Uppsala Conflict Data Program (UCDP) (http://ucdp.uu.se/downloads/)<br/><br/><strong><i>Authors</i></strong><br/><br/>This data visualization was realized by <strong>RaphaÃ«l Steinmann</strong> in the scope of Prof. Robert West's Applied Data Analysis course at EPFL. It comes along with a deeper analysis in the form of a data story realized by <strong>Louis Duvigneau</strong> and <strong>Malo Grisard</strong> (see link on the right).<br/><br/><strong><i>Running compatibilities</i></strong><br/><br/>This viz was developped and tested on Google Chrome. As this project was conducted in less than two months, there is no guarantee that it runs perfectly on other browsers.";
    }

    // prints the instruction pop-up at the beginning of the viz
    function printInstructionsBubble(delay){
        let elemwidth = 400;
        let elemheight = 60;
        console.log(width)
        let bubble = d3.select('#container')
            .append('div')
            .attr('id', 'instructions')
            .style('width', elemwidth+'px')
            //.style('height', elemheight+'px')
            .style('left', width/2-elemwidth/2 + 'px')
            .style('position', 'absolute')
            .html(instructionsToString())
            .style('top', '-300px')
            .transition().delay(delay).duration(1000)
            .style('top', '170px')
            .transition().delay(0).duration(400)
            .style('top', '150px');
    }

    // removes the instructions popup
    // called only once the first time an arrow key is pressed
    // or the mouse is scrolled
    function removeInstructionsBubble(){
        d3.select('#instructions')
            .style('top', '150px')
            .transition().delay(100).duration(600)
            .style('top', '-400px')
            .remove();
    }

    // do this in a closure so that it can be executed only once
    /*var removeInstructionsBubble = (function() {
        var executed = false;
        return function() {
            if (!executed) {
                executed = true;
                d3.select('#instructions')
                    .transition().delay(4000).duration(0)
                    .style('top', '150px')
                    .transition().duration(600)
                    .style('top', '-400px')
                    .remove();
            }
        };
    })();*/

    /*function colorScale(c1, c2){
        var legend_box = d3.select("#legendBox"),
        length = 10,
        color = d3.scaleLinear().domain([1,length])
          .interpolate(d3.interpolateHcl)
          .range([d3.rgb(c1), d3.rgb(c2)]);


      for (var i = 0; i < length; i++) {
        legend_box.append('div').attr('class', 'colorBox').attr('style', function (d) {
          return 'background-color: ' + color(i);
        });
      }
    }

    let red1 = d3.hsl(360, 0.3, 0.5);
    let red2 = d3.hsl(360, 1, 0.5);
    colorScale(red1, red2)*/

</script>
</html>
<!--
Todo-List

TODO hide/show PA comments
TODO add end_comment 'why did this PA end?' to PAs
TODO write viz description for tooltip

TODO don't forget to put back begin date to real first day
TODO leave a few seconds to load the data (data does not appear if you scroll immediately)



DONE onclick country display a 2nd section 'past conflicts' to see the past PAs
DONE information window to explain the viz
DONE UN logo on the map
DONE white background on UN logo?
DONE onmouseover conflict highlight country on map
DONE onmouseover conflict circle, can also select country (this helps for small countries)
DONE static infocell header
DONE different color/icon for UN peace treaties (on the map and on the infopanel, and add a UN logo on the PA cells)
DONE onclick a country, show icons showing the number of active/broken PAs so far
DONE PA border color red if PA is broken, blue if active, grey if not active yet
DONE add PAs descriptions
DONE replace Jan 2099 by 'today'
DONE add only one cell "show PAs..." per conflict if there are PAs and onclick this cell, expand it to show all the PAs
DONE import and display peace treaties
DONE add infocell header
DONE onclick country: filter the events and display only the events of this country
DONE fix the way conflicts are displayed in the info panel: Some are displayed more than once
DONE scrollable div
DONE info pannel on the right
DONE onmouseover -> display name popup
DONE Borders should be still visible when green/red contries

wontdos
TODO add legend on top of the map for icon/circle + color meaning (wontdo, infopanel is enough)
TODO don't dispaly PAs for past conflicts? Yes because we can see if there is stability in the region
TODO timeline on the bottom
TODO color switch smooth transition
TODO extra: double click -> show induvidual events inside country
TODO extra: zoom

Ideas
Put PAs in the conflict box and onclick expand and show infos about PA
Circles for PAs: deacreasing radius over time
path animation on selected country

Issues:
* for the moment, I plot a blue circle if at least one PA is active in the country
* that's not okay because in some countries an old PA that's active forever keeps the blue dot
* but since then there has been other conflicts in the country.

* solution: either set the enddate of an infinite peace treaty to the end on the conflict
* or always display the most recent peace treaty
* or display each and every treaty with a small blue/red cross with a random offset from the center

________________________________________________________________

PAs Data Structure

PeaceAgreementsById: store all PAs in a dict (key: PAID or CID)
PeaceAgreementsByCountry: store for each countryID the 


solution 1:
* store PAs by PAID
* each conflict has a list of PAIDs
* + easy to get PAs from conflicts (info pannel)
* - to get by country: get country's CIDs, then for each CID get the PAIDs

solution 2:
* store PAs by PAID
* for each region store a list of PAIDs 

solution 3:
* do both
-->

<!doctype html>
<html>
<head>
    <style type="text/css">

        body{
            background-color: grey;
            font-family: "Verdana", sans-serif;
            color: rgb(10, 10, 10);
        }

        #container{
            position: relative;
            overflow: auto;
            width: 100%;
            height:100%;
        }

        #mapContainer{
            position: fixed;
            float: left;
            left: 0px;
            right: 0px;
            top: 0px;
            bottom: 0px;
            background-color: transparent;
            width: 70%;
            height: 100%;
        }
        #infoContainer{
            float: right;
            width: 29%;
            border-radius: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .infocell, .infocell_past{
            margin: 10px;
            padding: 5px;
            border-radius: 10px;
            /*background-color: rgba(255, 255, 255, 0.3);*/
            background-color: rgb(180, 180, 180);
            font-size: 13px;

            border-style: solid;
            border-width: 2px;
            border-color: transparent;
        }

        .cell_pa{
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            margin: 1px;
            margin-bottom: 5px;
            margin-top: 5px;
            padding: 5px;
            font-size:12px;
            border-width: 1px;
            /*border-color: rgb(0, 0, 255);*/
            border-style: solid;
        }

        .cell_pa_un{
            background-image: url(data/un_logo.png);
            background-repeat: no-repeat;
            background-position: 98% 8px;
            background-size: 60px;
        }

        #infocell-header{
            white-space:nowrap;
            padding-top: 25px;
            margin-bottom: 30px;
            margin-left: 10px;
            position: sticky;
            top: 0;
            z-index: 2;
        }

        #filter-header{
            border-style: solid;
            border-width: 2px;
            border-color: rgb(70, 70, 70);
            border-radius: 10px;
            text-align: center;

            padding: 10px;
            padding-top: 15px;
            padding-bottom: 15px;
            
            /*background-color: rgba(255, 255, 255, 0.3);*/
            background-color: rgb(180, 180, 180);
            font-size: 14px;
        }

        #dateContainer{
            white-space:nowrap;
            /*height:50px;*/
            text-align:center;
            /*line-height: 50px;*/
            /*display: block;*/

            /*background-color: rgba(255, 255, 255, 0.3);*/
            background-color: rgb(180, 180, 180);
            font-size: 14px;
            border-radius: 10px;
            border-color: rgb(70, 70, 70);
            border-style: solid;
            border-width: 2px;

            margin-left: auto;
            margin-right: 10px;
            
            padding: 10px;
            padding-top: 15px;
            padding-bottom: 15px;
        }

        #month{
            width: 30px;
            display: inline-block;
        }

        path {
            stroke: rgb(200, 200, 200);
            stroke-width: 0.5px;
            stroke-linejoin: bevel;
        }

        .circles{
            stroke: blue;
            fill: transparent; 
            stroke-width: 2px;
        }

        .show_pa{
            text-align: center;
        }

        .pa_logo{
            float: right;
            width:18px;
        }

        .infodiv{
            padding-left: 8px;
            padding-top: 3px;
            position: absolute;
            color:rgb(50, 50, 50);
        }

        .tooltip{  
            position: absolute;         
            text-align: left;         
            width: 400px;                 
            padding: 20px;               
            font: 13px sans-serif;      
            background: white; 
            border: 0px;        
            border-radius: 10px;         
            pointer-events: none;
        }

        /*div.colorBox{
            width: 20px;
            height: 10px;
        }

        div#legendBox{
            height: 100px;
        }*/

    </style>
    <script src="https://d3js.org/d3.v4.min.js"> </script>
    <script src="//d3js.org/topojson.v1.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body>
    <div id='container'>
        <!--<div id='legendBox'></div>-->
        <div id='infoContainer'>
            <div id='infocell-header'>
                <span id='filter-header'></span>
                <span id='dateContainer'>
                    <span id='month'></span>
                    <span id='year'></span>
                </span>
            </div>
        </div>
        <div id='mapContainer'>
            
        </div>
    </div>
</body>
<script type="text/javascript">

    // ___________________________________________ GLOBAL VARIABLES ___________________________________________


    const MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const PATH_TO_MAP = './data/countries.geo.json';
    const STEP_SIZE = 40; // represents the speed of the slider
    const START_DATE = new Date("1970-01-01");
    const END_DATE = new Date("2016-12-01");
    let current_date = START_DATE;
    let mapContainer = d3.select("#mapContainer");
    let infoContainer = d3.select('#infoContainer');
    let countries;
    let conflicts = {}; // all conflicts, sorted by location id
    let conflicts_by_id = {}; // all conflicts, sorted by conflict id
    let agreements_by_loc = {};
    let agreements_by_id = {};
    let width = mapContainer.node().clientWidth;
    let height = mapContainer.node().clientHeight;
    let margin = 8;
    let selected_country_id = null;

    //colors
    const MAP_STROKE_HL_COLOR = 'rgb(255, 255, 255)';
    const MAP_STROKE_COLOR = 'rgb(200, 200, 200)';

    const ACTIVE_PA_COLOR = 'rgb(0, 0, 255)';
    const BROKEN_PA_COLOR = 'rgb(255, 0, 0)';
    const FORTH_PA_COLOR = 'rgba(0, 0, 0, 0.5)'

    const CELL_BORDER_COLOR = 'rgb(70, 70, 70)';
    const UN_COLOR = 'rgb(91, 146, 229)';


    // ___________________________________________ DOM ELEMENTS ___________________________________________


    infoContainer.style('height', height-margin*2+'px');

    // add infocell header
    infoContainer
    .select('#filter-header')
        .html(d => infoHeaderToString())
        .style('opacity', 0)
        .transition()
        .style('opacity', 1);

    printInfoIcon();


    // ___________________________________________ IMPORT DATA ___________________________________________

    // Conflicts data
    d3.tsv("./data/conflicts.csv")
    .row(function(d) {
        var startdatesplit = d.startdate.split('-');
        var startdate = new Date(parseInt(startdatesplit[0]), parseInt(startdatesplit[1])-1, parseInt(startdatesplit[2]));
        var enddatesplit = d.enddate.split('-');
        var enddate = new Date(parseInt(enddatesplit[0]), parseInt(enddatesplit[1])-1, parseInt(enddatesplit[2]));
        // split locations, in case there are several locations for a single conflict
        d.locationID.split(',').forEach(function(loc_id){
            // create the dict entry if it does not exist yet
            if(!conflicts[loc_id]) conflicts[loc_id] = [];
            // push the data in the dict
            conflicts[loc_id].push({'start':startdate, 'end':enddate, 'locations':d.location, 'conflict_id':d.conflictid, 'sidea':d.sidea, 'sideb':d.sideb});
        });

        conflicts_by_id[d.conflictid] = {'locations':d.location, 'sidea':d.sidea, 'sideb':d.sideb, 'start':startdate, 'end':enddate, 'locationIDs':d.locationID.split(',')};
    })
    .get(function(err, rows) {
        if (err) return console.error(err);
    });

    // Peace Agreements data
    d3.tsv("./data/peace_agreements.csv")
        .row(function(row){
            var startdatesplit = row.pa_date.split('-');
            var startdate = new Date(parseInt(startdatesplit[0]), parseInt(startdatesplit[1])-1, parseInt(startdatesplit[2]));
            var enddatesplit = row.enddate.split('-');
            var enddate = new Date(parseInt(enddatesplit[0]), parseInt(enddatesplit[1])-1, parseInt(enddatesplit[2]));
            let un = row.UN == '0'? false : true;
            // store PAs by PAIDs
            agreements_by_id[row.PAID] = {'name':row.pa_name, 'start':startdate, 'end':enddate, 'comment':row.pa_comment, 'end_comment':row.c_duration, 'link':row.link, 'locationID':row.locationID, 'cid':row.CID, 'UN': un};
            // store PAIDs by location
            row.locationID.split(',').forEach(function(loc_id){
                // create the dict entry if it does not exist yet
                if(!agreements_by_loc[loc_id]) agreements_by_loc[loc_id] = [];
                // push the data in the dict
                agreements_by_loc[loc_id].push(row.PAID);
            });
            // store an array of its PAIDs in each conflict
            if(!conflicts_by_id[row.CID]['PAIDs']) conflicts_by_id[row.CID]['PAIDs'] = [];
            conflicts_by_id[row.CID]['PAIDs'].push(row.PAID);

        })
        .get(function(err, rows) {
            if (err) return console.error(err);
        });


    // ___________________________________________ MAP DISPLAY ___________________________________________


    let svg = mapContainer.append('svg')
        .attr('width', width)
        .attr('height', height)
        .on('click', function(d){
            selected_country_id = null;
            // remove all past conflicts cells
            infoContainer.selectAll('.infocell_past').remove();
            updateMapAndInfo();
            updateInfoHeader();
        });

    let mapLayer = svg.append('g');

    // projection of the world map
    var projection = d3.geoMercator().scale(width / 2 / Math.PI).translate([width/2, height/2+140]);

    let path = d3.geoPath().projection(projection);

    let centroids = {};
    
    d3.json(PATH_TO_MAP, function(err, geojson) {

        countries = mapLayer.selectAll("path")
        .data(geojson.features)
        .enter().append("path")
        .attr("d", path)
        .attr('id', country => country.id)
        .attr('name', country => country.properties.name)
        .on('mouseover', function(d,i){
            d3.select(this).style('stroke', MAP_STROKE_HL_COLOR);
            d3.select(this).style('stroke-width', 2);
        })
        .on('mouseout', function(d, i){
            d3.select(this).style('stroke', MAP_STROKE_COLOR);
            d3.select(this).style('stroke-width', 0.5);
        })
        .on('click', function(d){
            selected_country_id = d.id;
            updateMapAndInfo();
            updateInfoHeader(d.properties.name);
            d3.event.stopPropagation();
        })
        .append('svg:title').text(function(d, i){return d.properties.name});

        var features = geojson.features;
        features.map(function(f){
            return {'path':path.centroid(f), 'id':f.id};
        }).forEach(c => centroids[c.id] = c.path);
    });




    // ___________________________________________ UPDATE MAP ___________________________________________


    svg.node().addEventListener("mousewheel", function(e){
        onScrollEvent(e.wheelDelta < 0)
    }, false);


    // This function is called at each mouseWheelEvent
    // direction: true if scroll forward, false if backwards
    function onScrollEvent(direction){
        // update the current date
        updateDate(direction);
        printDate(current_date);
        // update the countries' colors
        updateMapAndInfo();
    }

    // updates the respective color of each country on the map
    // and the info panel on the right
    function updateMapAndInfo(){
        let ongoingConflits = new Set();
        let pastConflicts = new Set();
        let locsWithPA = new Set();
        let locsWithUNPA = new Set();
        Object.keys(conflicts).forEach(function(loc_id){
            let status = getConflictStatus(current_date, loc_id);
            let color = getColor(status.status, status.duration);
            // fill the country with the appropriate color
            mapLayer.select('path#'+loc_id).style('fill', color);
            // Fill the array of ongoing conflicts for the info pannel
            if(selected_country_id == null || loc_id == selected_country_id){
                status.ongoingConflits.forEach(conflict => ongoingConflits.add(conflict));
            }
            // only add past conflicts if a location is selected
            if(loc_id == selected_country_id && selected_country_id != null){
                status.pastConflicts.forEach(cid => pastConflicts.add(cid));
            }
            // Store each location that has at least one active PA
            if(agreements_by_loc[loc_id]){
                paStatus = locPaStatus(current_date, loc_id);
                if(paStatus.ongoingPA){
                    if(paStatus.is_un){
                        locsWithUNPA.add(loc_id);
                    }
                    else{
                        locsWithPA.add(loc_id); 
                    }
                }

            }
        });   
        updateInfoPanel(Array.from(ongoingConflits), Array.from(pastConflicts));
        updateInfocells();
        updateAgreementCells();
        updateUNCircles(locsWithUNPA);
        updateCircles(locsWithPA);
    }


    // draw a blue circle at the centroid of each location in the input array
    // the array contains all the locations that have at least one active PA
    // remove circles from other locations
    function updateCircles(loc_ids){
        let circles = svg.selectAll('.circles').data(Array.from(loc_ids), x => x);
        circles.enter()
            .append('circle')
            //.append('image')
            //.attr('xlink:href','data/un_logo.png')
            //.attr('width', '20')
            .on('mouseover', function(d){
                mapContainer.select('path#'+d).style('stroke', MAP_STROKE_HL_COLOR);
                mapContainer.select('path#'+d).style('stroke-width', 2);
            })
            .on('mouseout', function(d){
                mapContainer.select('path#'+d).style('stroke', MAP_STROKE_COLOR);
                mapContainer.select('path#'+d).style('stroke-width', 0.5);
            })
            .on('click', function(d){
                selected_country_id = d;
                updateMapAndInfo();
                updateInfoHeader(mapContainer.select('path#'+d).attr('name'));
                d3.event.stopPropagation();
            })
            //.append('svg:title').text(function(d, i){return 'test'})
            .classed('circles', true)
            .attr('cx', x => centroids[x][0])
            .attr('cy', x => centroids[x][1])
            .attr('id', x => 'circle_' + x)
            .attr('r', 0)
            .transition()
            .attr('r', 6)
            .transition()
            .attr('r', 3);

        circles.append('svg:title').text(function(d, i){return mapContainer.select('path#'+d).attr('name')});

        circles.exit()
            .attr('r', 3)
            .transition()
            .attr('r', 0)
            .remove();
    }


    // same as UpdateCircles() but draws UN logos instead of circles
    function updateUNCircles(loc_ids){
        let circles = svg.selectAll('.un_circles').data(Array.from(loc_ids), x => x);
        let icon_width = 12;
        circles.enter()
            .append('image')
            .attr('xlink:href','data/un_bg.png')
            .attr('width', '20')
            .on('mouseover', function(d){
                mapContainer.select('path#'+d).style('stroke', MAP_STROKE_HL_COLOR);
                mapContainer.select('path#'+d).style('stroke-width', 2);
            })
            .on('mouseout', function(d){
                mapContainer.select('path#'+d).style('stroke', MAP_STROKE_COLOR);
                mapContainer.select('path#'+d).style('stroke-width', 0.5);
            })
            .on('click', function(d){
                selected_country_id = d;
                updateMapAndInfo();
                updateInfoHeader(mapContainer.select('path#'+d).attr('name'));
                d3.event.stopPropagation();
            })
            .classed('un_circles', true)
            .attr('x', x => centroids[x][0]-icon_width/2)
            .attr('y', x => centroids[x][1]-icon_width/2)
            .attr('id', x => 'circle_' + x)
            .attr('width', 0)
            .transition()
            .attr('width', 30)
            .transition()
            .attr('width', icon_width);

        circles.append('svg:title').text(function(d, i){return mapContainer.select('path#'+d).attr('name') + ' - UN intervention'});

        circles.exit()
            .attr('width', 20)
            .transition()
            .attr('width', 0)
            .remove();
    }
    // ___________________________________________ INFO PANEL ___________________________________________


    // This method is called on each scroll event to append new conficts 
    // and remove finished conflicts
    function updateInfoPanel(ongoing_cids, past_cids){
        appendInfocells(ongoing_cids, false);
        if(selected_country_id != null){
            appendInfocells(past_cids, true);
        }
        
    }

    // this methods appends a cell in the info_panel for each c_id in the input list
    // is_past is a boolean used to differentiate list of ongoing conflicts from list of past conflicts
    function appendInfocells(conflict_ids, is_past){
        let cell_class = is_past ? 'infocell_past' : 'infocell';
        let cells = d3.select('div#infoContainer').selectAll('.'+cell_class).data(conflict_ids, cft_id => cft_id);
        
        cells.exit()
            .remove();
        
        cells.enter()
            .append('div')
            .attr('class', cell_class)
            .attr('id', cid => 'infocell_' + cid)
            .attr('cid', cid => cid)
            .attr('open', '0')
            .on('click', function(d){showHideAgreements(d)})
            .on('mouseover', function(d){
                d3.select(this).style('border-color', CELL_BORDER_COLOR);
                if(hasAgreements(d)) d3.select(this).select('.show_pa').select('i').style('opacity', '1');
                //highlight the locations of the conflict on the map
                conflicts_by_id[d].locationIDs.forEach(function(loc){
                    mapContainer.select('path#'+loc).style('stroke', MAP_STROKE_HL_COLOR);
                    mapContainer.select('path#'+loc).style('stroke-width', 2); 
                });
            })
            .on('mouseout', function(d){
                d3.select(this).style('border-color', 'transparent');
                d3.select(this).select('.show_pa').select('i').style('opacity', '0.5');
                //highlight the locations of the conflict on the map
                conflicts_by_id[d].locationIDs.forEach(function(loc){
                    mapContainer.select('path#'+loc).style('stroke', MAP_STROKE_COLOR);
                    mapContainer.select('path#'+loc).style('stroke-width', 0.5);
                });
            })
            .html(cid => conflictToString(cid, is_past) + closedConflictToString(hasAgreements(cid)))
            .style('opacity', 0)
            .transition()
            .style('opacity', 1);
    }

    // updates in each infocell the number of active/broken PAs
    function updateInfocells(){
        infoContainer.selectAll('.infocell, .infocell_past').each(function(d){
            let cell = d3.select(this);
            let cid = cell.attr('cid');
            let pa_sums = getAgreementsSums(cid, current_date);
            cell.select('.pa_sums').html(paSumsToString(pa_sums));
        });
    }

    // returns html code to fill the header of the infocells
    function infoHeaderToString(locationName=null){
        let res;
        if(locationName){
            let locName = locationName.length > 15 ? selected_country_id : locationName;
            res = "Ongoing conflicts in <strong>" + locName + "</strong>";
        }
        else{
            res = '<i style="opacity:0.5;">Click on any country to select it</i>';
        }

        return res;
    }

    function updateInfoHeader(locationName=null){
        infoContainer.select('#filter-header').html(infoHeaderToString(locationName));
    }

    // this function is called when a conflict cell in the infopanel is clicked
    // it shows/hides the 
    function showHideAgreements(cid){
        if(!conflicts_by_id[cid].PAIDs){
            console.log("no PAs")
            return;
        }
        let cell = d3.select('#infocell_'+cid);
        if(cell.attr('open') == '0'){
            cell.attr('open', '1')
            .append('div')
                .attr('class', 'pas_container')
                .html(agreementsToString(cid))
                .style('opacity', 0)
                .transition()
                .style('opacity', 1);
            cell.select('.show_pa').remove();
            cell.append('div').html("<div class=show_pa><i style='opacity:0.5'>Click on the cell to hide the peace agreements ...</i></div>");
        }
        else{
            cell.attr('open', '0')
                .select('.pas_container')
                .remove();
            cell.select('.show_pa').remove();
            cell.append('div').html(closedConflictToString(true));
        }
    }


    // ___________________________________________ CONFLICTS METHODS ___________________________________________


    // returns a string decribing the conflict for the infopanel
    function conflictToString(c_id, is_past){
        let c = conflicts_by_id[c_id];
        let res = "";
        let pas_sums = getAgreementsSums(c_id, current_date);
        //res += "<div style='text-align:center'><i style='opacity:0.5'>Conflict #" + c_id + "</i></div>";
        res += "<div style='text-align:right'><span style='opacity:0.5; font-size: 10px'>Conflict #" + c_id + "</span></div>";
        // active/broken PAs count
        res += "Location: " + c.locations;
        res += is_past ? '<br/>Conflict status: <span style="color:green;">resolved</span>' : '<br/>Conflict status: <span style="color:red;">active</span>';
        res += "<br/>Duration: " + dateToString(c.start) + " - " + dateToString(c.end);
        res += "<br/>Side A: " + c.sidea + "<br/>Side B: " + c.sideb;
        if(pas_sums){
            res += "<span class='pa_sums'>";
            res += paSumsToString(pas_sums);
            res += "</span>";
        }
        return res;
    }

    // returns true if there is at least one conflict in the country, false otherwise
    function isInConflict(date, country){
        return conflicts[country].some(conflict => (date > conflict.start && date < conflict.end));
    }

    // This function returns the status of the country at the given date
    // and for how long this status has been lasting
    // it also returns an array containing the ongoing conflicts
    // true: conflict, false: no conflict (i.e. peace)
    // country: country id
    function getConflictStatus(current_date, country){
        let ongoingConflits = conflicts[country].filter(c => (current_date > c.start && current_date < c.end));
        let pastConflicts = conflicts[country].filter(c => (c.end >= START_DATE && current_date > c.start && current_date >= c.end));
        let status, duration;

        // The country is at peace
        if(ongoingConflits.length == 0){
            status = false;
            let latestPeaceDay = d3.max([START_DATE, d3.max(conflicts[country].map(c => c.end).filter(end => end < current_date))]);
            duration = msToDays(current_date - latestPeaceDay);
        }
        // Only one conflict in the country at that time
        else if(ongoingConflits.length == 1){
            status = true;
            duration = msToDays(current_date - ongoingConflits[0].start);
        }
        // more than one conflict at that time
        else{
            status = true;
            duration = msToDays(current_date - d3.min(ongoingConflits, c => c.start));
        }
        return {'status': status, 'duration':duration, 'ongoingConflits':ongoingConflits.map(c => c.conflict_id), 'pastConflicts':pastConflicts.map(c => c.conflict_id)};
    }

    // returns the corresponding color (red for conflict, green for peace)
    // the duration determines the intensity (saturation) of the color
    // status: boolean indicating wether there is a conflict of not
    // duration: for how long has this status been lasting?
    function getColor(status, duration){
        let hue = status ? 360 : 100;
        let scale = d3.scaleLinear().domain([0, 5000]).range([0.3, 1]).clamp(true);
        let saturation = scale(duration);

        let color = d3.hsl(hue, saturation, 0.5);
        return color.rgb();
    }

    // returns html code containing 'show more' message
    function closedConflictToString(has_pas){
        let text = has_pas ? 'Click on the cell to see the peace agreements ...' : 'No peace agreement for this conflict';
        return "<div class=show_pa><i style='opacity:0.5'>" + text + "</i></div>";
    }


    // ___________________________________________ AGREEMENTS METHODS ___________________________________________



    // returns html code that contains info about how many PAs are active/broken
    function paSumsToString(pa_sums){
        let res = "<div> Active/Broken peace agreements: ";
        // active United Nations PAs
        for(let i = 0; i < pa_sums.activeUn; i++){
            res += '<img src="data/un_logo.png" style="padding-left: 3px; width:20px;">';
        }
        // broken United Nations PAs
        for(let i = 0; i < pa_sums.brokenUn; i++){
            res += '<img src="data/un_logo_cross.png" style="padding-left: 3px; width:20px;">';
        }
        // active Non-UN PAs
        for(let i = 0; i < pa_sums.activeNonUn; i++){
            res += '<i class="test fa fa-check-circle-o" aria-hidden="true" style="text-weight:bold; padding-left: 3px;font-size:16px; color:'+ ACTIVE_PA_COLOR +'"></i>';
        }
        // broken Non-UN PAs
        for(let i = 0; i < pa_sums.brokenNonUn; i++){
            res += '<i class="test fa fa-times-circle-o" aria-hidden="true" style="text-weight:bold; padding-left: 3px;font-size:16px; color:'+ BROKEN_PA_COLOR +'"></i>';
        } 
        res += "</div>";
        return res;
    }

    // if cid has PAs, returns the list of its PAIDs, false otherwise
    function hasAgreements(cid){
        return conflicts_by_id[cid].PAIDs;
    }

    
    // returns html element containing textual representation of all the PAs relative to the input conflict
    function agreementsToString(cid){
        let result = "";
        let paids = conflicts_by_id[cid].PAIDs;
        if(!paids) return result;
        paids.forEach(function(paid){
            result += '<span onclick="openClosePA(this);" open="0">';
            result += closedAgreementToString(paid);
            result += '</span>'
        });
        return result;
    }

    function closedAgreementToString(paid){
        result = "";
        let pa = agreements_by_id[paid];
        let pa_status = getAgreementStatus(pa);
        // put the UN logo if it's a UN treaty
        let cell_class = pa.UN ? 'cell_pa cell_pa_un' : 'cell_pa';
        result += "<div class='" + cell_class + "' paid='" + paid + "' style='border-color: transparent;' onmouseover='agreementCellBorder(this, true);' onmouseout='agreementCellBorder(this, false)'>";
        result += "<div style='text-align:center'><strong><i style='opacity:1'>" + pa.name + "</i></strong></div>";
        let statusString = "<span class='pa_status' style='color: " + pa_status.color + "'><span> (" + pa_status.status + ")</span></span>";
        result += "<br/>Duration: " + dateToString(pa.start) + " - " + dateToString(pa.end) + statusString;
        result += "<br/><br/><div style='text-align: center;'><i style='opacity:0.5'>Click to learn more about this agreement ...</i></div>";
        result += "</div>";
        return result;

    }

    // this function opens/closes a PA when it is clicked
    // input: clicked DOM element (PA cell)
    function openClosePA(cell){
        event.stopPropagation();
        let elem = d3.select(cell);
        let open = (elem.attr('open') == '1');
        if(open){
            elem.html(closedAgreementToString(elem.select('div').attr('paid'))); 
            elem.attr('open', '0');
        }
        else{
            elem.html(openedAgreementToString(elem.select('div').attr('paid')));
            elem.attr('open', '1');
        }
    }

    function openedAgreementToString(paid){
        result = "";
        let pa = agreements_by_id[paid];
        let pa_status = getAgreementStatus(pa);
        // put the UN logo if it's a UN treaty
        let cell_class = pa.UN ? 'cell_pa cell_pa_un' : 'cell_pa';
        result += "<div class='" + cell_class + "' paid='" + paid + "' style='border-color: transparent;' onmouseover='agreementCellBorder(this, true);' onmouseout='agreementCellBorder(this, false)'>";
        result += "<div style='text-align:center'><strong><i style='opacity:1'>" + pa.name + "</i></strong></div>";
        let statusString = "<span class='pa_status' style='color: " + pa_status.color + "'><span> (" + pa_status.status + ")</span></span>";
        result += "<br/>Duration: " + dateToString(pa.start) + " - " + dateToString(pa.end) + statusString;
        result += "<br/><br/><div style='white-space: pre-line'>" + pa.comment + "</div>";
        result += "<br/><br/><div style='text-align: center;'><i style='opacity:0.5'>Click the cell to close it</i></div>";
        result += "</div>";
        return result;
    }

    // highlights the input PA cell in the color representing the PA status
    // over: true if mouseover, false if mouseout
    function agreementCellBorder(cell, over){
        if(!over) d3.select(cell).style('border-color', 'transparent');
        else{
            let paid = d3.select(cell).attr('paid');
            let color = getAgreementStatus(agreements_by_id[paid]).color;
            d3.select(cell).style('border-color', color);
        }
    }

    // updates the textual status of the visible PA cells (broken, active, forthcoming)
    function updateAgreementCells(){
        let cells = d3.selectAll('.infocell, .infocell_past').filter(function(d){return d3.select(this).attr('open') == '1';}).selectAll('.cell_pa');
        cells.each(function(d){
            let cell = d3.select(this);
            let pa = agreements_by_id[cell.attr('paid')];
            let pa_status = getAgreementStatus(pa);
            // edit the status text in the cell
            cell.select('span.pa_status').html("<span style='color: " + pa_status.color + "'> (" + pa_status.status + ")</span>");
        });
    }

    // returns a boolean if there's at least one ongoing PA and the list of ongoing PAs
    // returns the same thing for broken PAs
    function locPaStatus(current_date, country_id){
        let ongoingPas = agreements_by_loc[country_id].map(paid => agreements_by_id[paid]).filter(pa => (current_date >= pa.start && current_date < pa.end));
        let ongoingUnPas = ongoingPas.filter(pa => pa.UN);
        return {'ongoingPA': (ongoingPas.length > 0), 'is_un':(ongoingUnPas.length > 0)};
        //let brokenPas = agreements_by_loc[country_id].map(paid => agreements_by_id[paid]).filter(pa => (current_date >= pa.start && current_date >= pa.end));
        //return {'ongoingPA':(ongoingPas.length > 0), 'brokenPA':(brokenPas.length > 0), 'ongoingPas':ongoingPas, 'brokenPas':brokenPas};
    }

    // returns the number of active/broken agreements of the input conflict at the input date
    function getAgreementsSums(cid, date){
        if(!hasAgreements(cid)) return false;
        let pas = conflicts_by_id[cid].PAIDs.map(paid => agreements_by_id[paid]);
        let activePas = pas.filter(pa => (current_date >= pa.start && current_date < pa.end));
        let activeUn = activePas.filter(pa => pa.UN);
        let brokenPas = pas.filter(pa => (current_date >= pa.start && current_date >= pa.end));
        let brokenUn = brokenPas.filter(pa => pa.UN);
        return {'activeNonUn':(activePas.length - activeUn.length), 'brokenNonUn':(brokenPas.length - brokenUn.length), 'activeUn':activeUn.length, 'brokenUn':brokenUn.length};
    }

    // returns the status (forthcoming, broken, active) of the
    // input PA and the corresponding color
    function getAgreementStatus(pa){
        if(pa.start > current_date){
            return {'status': 'Forthcoming', 'color': FORTH_PA_COLOR};
        }
        else if(pa.end <= current_date){
            return {'status': 'Broken', 'color': BROKEN_PA_COLOR};
        }
        else if(pa.start <= current_date && pa.end > current_date){
            return {'status': 'Active', 'color': ACTIVE_PA_COLOR};
        }
        else{
            console.error('Agreement color error, this should not happen');
            return {'status': 'Forthcoming', 'color': FORTH_PA_COLOR};
        }
    }

    function getAgreementColor(pa){
        if(pa.start > current_date) return 'transparent';
        else if(pa.end <= current_date) return BROKEN_PA_COLOR;
        else if(pa.start <= current_date && pa.end > current_date) return ACTIVE_PA_COLOR;
        else{
            console.error('Agreement color error, this should not happen');
            return 'transparent';
        }
    }

    // ___________________________________________ DATE PANEL ___________________________________________


    function dateToString(date){
        return date.getFullYear() == 2099 ? 'today' : MONTH_NAMES[date.getMonth()] + " " + date.getFullYear();
    }

    // prints the input date in the date container
    function printDate(date){
        d3.select('#month').html(MONTH_NAMES[date.getMonth()]);
        d3.select('#year').html(date.getFullYear());
    }

    // This void function updates the global 'current_date' variable after a scrollEvent
    // direction: the scroll direction that defines if we go back or forward in time
    function updateDate(direction){
        // are we scrolling up or down?
        let step = direction ? STEP_SIZE : -STEP_SIZE;
        let new_date = d3.timeDay.offset(current_date, step);

        // clamp the date
        if(new_date < START_DATE){
            current_date = START_DATE;
        }
        else if(new_date > END_DATE){
            current_date = END_DATE;
        }
        else{
            current_date = new_date;
        }
    }


    // ___________________________________________ HELPER METHODS ___________________________________________


    // input: a duration in ms
    // output: the same duration in days
    function msToDays(ms){
        return Math.round(ms/(1000*60*60*24));
    }

    // prints an information icon at the top left of the page
    // onmouseover this icon, some info about the viz is displayed
    function printInfoIcon(){
        d3.select('#container')
            .append('div')
            .html( '<i class="infodiv fa fa-info-circle" aria-hidden="true" style="font-size: 30px"></i>')
            .on("mouseover", function(d) {      
                div.transition()        
                    .duration(200)      
                    .style("opacity", .8);      
                div .html(vizInfoToString())  
                    .style("left", '40px')     
                    .style("top", '10px');    
            })                  
            .on("mouseout", function(d) {       
                div.transition()        
                    .duration(500)      
                    .style("opacity", 0);   
            });

        var div = d3.select("#container").append("div")   
            .attr("class", "tooltip")               
            .style("opacity", 0);
    }

    function vizInfoToString(){
        return "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum nec nibh nec justo tempor aliquet. Nulla ornare gravida quam, quis posuere eros vulputate id. Ut lacinia volutpat urna, a semper nisi ullamcorper eget. Pellentesque sed neque in magna congue feugiat gravida at lacus. Pellentesque bibendum mi metus, quis faucibus nisi viverra et. Vestibulum a dictum quam, mattis porttitor justo. Mauris arcu orci, congue eu urna eu, eleifend imperdiet ipsum. Nulla pulvinar erat odio, at convallis lectus pellentesque eu. Praesent eros mi, blandit sit amet odio eget, condimentum lacinia quam. Curabitur ullamcorper magna eu diam aliquam semper. Mauris eget nisi eget nisi ornare tempus ac nec leo. Sed varius dolor massa, a euismod nisi auctor ac.<br/><br/>Sed quis arcu ipsum. Vestibulum ante turpis, congue a lectus quis, vehicula pulvinar elit. Curabitur lacinia sapien mauris, at vestibulum magna cursus ac. Nunc efficitur finibus neque. Aenean tortor lorem, iaculis at ligula non, hendrerit sagittis nisl. Pellentesque quam arcu, luctus ac sollicitudin non, congue in nunc. Maecenas at elit quis ante luctus dignissim id consectetur enim. Aenean porttitor blandit dui, non egestas mi tristique vitae. Fusce eleifend interdum dui eu pulvinar.";
    }

    /*function colorScale(c1, c2){
        var legend_box = d3.select("#legendBox"),
        length = 10,
        color = d3.scaleLinear().domain([1,length])
          .interpolate(d3.interpolateHcl)
          .range([d3.rgb(c1), d3.rgb(c2)]);


      for (var i = 0; i < length; i++) {
        legend_box.append('div').attr('class', 'colorBox').attr('style', function (d) {
          return 'background-color: ' + color(i);
        });
      }
    }

    let red1 = d3.hsl(360, 0.3, 0.5);
    let red2 = d3.hsl(360, 1, 0.5);
    colorScale(red1, red2)*/

</script>
</html>
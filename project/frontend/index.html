<!--
Todo-List
TODO Borders should be still visible when green/red contries
TODO import and display peace treaties
TODO info pannel on the right
TODO onclick -> display all events of the clicked country
TODO timeline on the bottom ?
TODO extra: double click -> show induvidual events inside country
DONE onmouseover -> display name popup
-->

<!doctype html>
<html>
<head>
    <style type="text/css">
        #container{
            position: fixed;
            left: 0px;
            right: 0px;
            top: 0px;
            bottom: 0px;
            background-color: grey;
            width: 100%;
            height: 100%;
        }

        #dateContainer{
            position: fixed;
            left: 5px;
            top: 5px;
            width: 7%;
            height:50px;
            background-color: white;
            opacity: 0.6;
            border-radius: 10px;
            text-align:center;
            line-height: 50px;
            display:block;
        }

        #month{
            width: 30px;
            display: inline-block;
        }
        path {
            stroke: rgb(200, 200, 200);
            stroke-width: 0.5px;
        }

    </style>
    <script src="https://d3js.org/d3.v4.min.js"> </script>
</head>
<body>
    <div id='container'>
        <div id='dateContainer'>
            <span id='month'></span>
            <span id='year'></span>
        </div>
    </div>
</body>
<script type="text/javascript">

    // ___________________________________________ GLOBAL VARIABLES ___________________________________________

    const MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const PATH_TO_MAP = './data/countries.geo.json';
    const STEP_SIZE = 40; // represents the speed of the slider
    const START_DATE = new Date("1945-01-01");
    const END_DATE = new Date("2017-01-01");
    let current_date = START_DATE;
    let container = d3.select("#container");
    let countries;
    let conflicts = {};
    //let width = container.node().clientWidth;
    //let height = container.node().clientHeight;
    let width = 960;
    let height = 700;


    // ___________________________________________ IMPORT DATA ___________________________________________

    // Loading the data
    d3.tsv("./data/conflicts.csv")
    .row(function(d) {
        var startdatesplit = d.startdate.split('-');
        var startdate = new Date(parseInt(startdatesplit[0]), parseInt(startdatesplit[1])-1, parseInt(startdatesplit[2]));
        var enddatesplit = d.enddate.split('-');
        var enddate = new Date(parseInt(enddatesplit[0]), parseInt(enddatesplit[1])-1, parseInt(enddatesplit[2]));
        // split locations, in case there are several locations for a single conflict
        d.location.split(',').forEach(function(location){
            // create the dict entry if it does not exist yet
            if(!conflicts[location]) conflicts[location] = [];
            // push the data in the dict
            conflicts[location].push({'start':startdate, 'end':enddate});
        });
    })
    .get(function(err, rows) {
        if (err) return console.error(err);
    });


    // ___________________________________________ MAP DISPLAY ___________________________________________

    let svg = container.append('svg')
        .attr('width', width)
        .attr('height', height);

    let mapLayer = svg.append('g');

    // projection of the world map
    var projection = d3.geoMercator().scale(width / 2 / Math.PI).translate([width/2, height/2+140]);
    
    d3.json(PATH_TO_MAP, function(err, geojson) {

        countries = mapLayer.selectAll("path")
        .data(geojson.features)
        .enter().append("path")
        .attr("d", d3.geoPath().projection(projection))
        .attr('id', country => country.properties.name)
        .on('mouseover', function(d,i){
            d3.select(this).style('stroke', 'rgb(255, 255, 255)');
            d3.select(this).style('stroke-width', 2);
        })
        .on('mouseout', function(d, i){
            d3.select(this).style('stroke', 'rgb(200, 200, 200)');
            d3.select(this).style('stroke-width', 0.5);
        })
        .append('svg:title').text(function(d, i){return d.properties.name});
    });


    // ___________________________________________ UPDATE MAP ___________________________________________

    svg.node().addEventListener("mousewheel", function(e){
        update(e.wheelDelta < 0)
    }, false);


    // ___________________________________________ HELPER METHODS ___________________________________________

    // prints the input date in the date container
    function printDate(date){
        d3.select('#month').html(MONTH_NAMES[date.getMonth()]);
        d3.select('#year').html(date.getFullYear());
    }

    // This void function updates the global 'current_date' variable after a scrollEvent
    // direction: the scroll direction that defines if we go back or forward in time
    function updateDate(direction){
        // are we scrolling up or down?
        let step = direction ? STEP_SIZE : -STEP_SIZE;
        let new_date = d3.timeDay.offset(current_date, step);

        // clamp the date
        if(new_date < START_DATE){
            current_date = START_DATE;
        }
        else if(new_date > END_DATE){
            current_date = END_DATE;
        }
        else{
            current_date = new_date;
        }
    }


    // This function is called at each mouseWheelEvent
    // direction: true if scroll forward, false if backwards
    function update(direction){
        // update the current date
        updateDate(direction);
        // update the countries' colors
        getStatusDuration(current_date, 'Russia');
        printDate(current_date);
        Object.keys(conflicts).forEach(function(c){
            let statusDuration = getStatusDuration(current_date, c);
            let color = getColor(statusDuration.status, statusDuration.duration);
            mapLayer.select('path#'+c).style('fill', color);
        });
    }


    // returns true if there is at least one conflict in the country, false otherwise
    function isInConflict(date, country){
        return conflicts[country].some(conflict => (date > conflict.start && date < conflict.end));
    }

    // input: a duration in ms
    // output: the same duration in days
    function msToDays(ms){
        return Math.round(ms/(1000*60*60*24));
    }

    // This function returns the status of the country at the given date
    // and for how long this status has been lasting
    // true: conflict, false: no conflict (i.e. peace)
    function getStatusDuration(current_date, country){
        let ongoingConflits = conflicts[country].filter(c => (current_date > c.start && current_date < c.end));
        let status, duration;
        //console.log(ongoingConflits);
        //console.log('size: ' + ongoingConflits.length);

        // The country is at peace
        if(ongoingConflits.length == 0){
            //console.log("no conflict");
            status = false;
            let latestPeaceDay = d3.max([START_DATE, d3.max(conflicts[country].map(c => c.end).filter(end => end < current_date))]);
            //console.log('latest peace day: ' + latestPeaceDay);
            duration = msToDays(current_date - latestPeaceDay);
            //console.log((conflicts[country].map(c => c.end).filter(end => end < current_date)));
        }
        // Only one conflict in the country at that time
        else if(ongoingConflits.length == 1){
            //console.log("one conflict");
            status = true;
            duration = msToDays(current_date - ongoingConflits[0].start);
        }
        // more than one conflict at that time
        else{
            //console.log("several conflicts");
            status = true;
            duration = msToDays(current_date - d3.min(ongoingConflits, c => c.start));
        }
        //console.log(duration + " days");
        return {'status': status, 'duration':duration};
    }

    function getRandomColor() {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }

    // returns the corresponding color (red for conflict, green for peace)
    // the duration determines the intensity (saturation) of the color
    // status: boolean indicating wether there is a conflict of not
    // duration: for how long has this status been lasting?
    function getColor(status, duration){
        let hue = status ? 360 : 100;
        let scale = d3.scaleLinear().domain([0, 5000]).range([0.3, 1]).clamp(true);
        let saturation = scale(duration);

        let color = d3.hsl(hue, saturation, 0.5);
        return color.rgb();
    }

</script>
</html>
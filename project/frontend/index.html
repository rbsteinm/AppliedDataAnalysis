<!--
Todo-List

TODO onclick a country, show icons showing the number of active/broken PAs so far
TODO different color/icon for UN peace treaties
TODO static infocell header
TODO hide/show PA comments
TODO add end_comment 'why did this PA end?' to PAs
TODO information window
TODO onmouseover conflict highlight country on map
TODO don't dispaly PAs for past conflicts?

TODO timeline on the bottom
TODO color switch smooth transition
TODO extra: double click -> show induvidual events inside country
TODO extra: zoom

DONE PA border color red if PA is broken, blue if active, grey if not active yet
DONE add PAs descriptions
DONE replace Jan 2099 by 'today'
DONE add only one cell "show PAs..." per conflict if there are PAs and onclick this cell, expand it to show all the PAs
DONE import and display peace treaties
DONE add infocell header
DONE onclick country: filter the events and display only the events of this country
DONE fix the way conflicts are displayed in the info panel: Some are displayed more than once
DONE scrollable div
DONE info pannel on the right
DONE onmouseover -> display name popup
DONE Borders should be still visible when green/red contries

Ideas
Put PAs in the conflict box and onclick expand and show infos about PA
Circles for PAs: deacreasing radius over time
path animation on selected country

Issues:
* for the moment, I plot a blue circle if at least one PA is active in the country
* that's not okay because in some countries an old PA that's active forever keeps the blue dot
* but since then there has been other conflicts in the country.

* solution: either set the enddate of an infinite peace treaty to the end on the conflict
* or always display the most recent peace treaty
* or display each and every treaty with a small blue/red cross with a random offset from the center

________________________________________________________________

PAs Data Structure

PeaceAgreementsById: store all PAs in a dict (key: PAID or CID)
PeaceAgreementsByCountry: store for each countryID the 


solution 1:
* store PAs by PAID
* each conflict has a list of PAIDs
* + easy to get PAs from conflicts (info pannel)
* - to get by country: get country's CIDs, then for each CID get the PAIDs

solution 2:
* store PAs by PAID
* for each region store a list of PAIDs 

solution 3:
* do both
-->

<!doctype html>
<html>
<head>
    <style type="text/css">

        body{
            background-color: grey;
            font-family: "Verdana", sans-serif;
            color: rgb(10, 10, 10);
        }

        #container{
            position: relative;
            overflow: auto;
            width: 100%;
            height:100%;
        }

        #mapContainer{
            position: fixed;
            float: left;
            left: 0px;
            right: 0px;
            top: 0px;
            bottom: 0px;
            background-color: transparent;
            width: 70%;
            height: 100%;
        }
        #infoContainer{
            float: right;
            width: 29%;
            border-radius: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .infocell{
            margin: 10px;
            padding: 5px;
            border-radius: 10px;
            background-color: rgba(255, 255, 255, 0.3);
            font-size: 13px;

            border-style: solid;
            border-width: 2px;
            border-color: transparent;
        }

        .cell_pa{
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            margin: 1px;
            margin-bottom: 5px;
            margin-top: 5px;
            padding: 5px;
            font-size:12px;
            border-width: 1px;
            /*border-color: rgb(0, 0, 255);*/
            border-style: solid;
        }

        #infocell-header{
            white-space:nowrap;
            margin-top: 25px;
            margin-bottom: 30px;
            margin-left: 10px;
        }

        #filter-header{
            border-style: solid;
            border-width: 2px;
            border-color: rgb(70, 70, 70);
            border-radius: 10px;
            text-align: center;

            padding: 10px;
            padding-top: 15px;
            padding-bottom: 15px;
            
            background-color: rgba(255, 255, 255, 0.3);
            font-size: 14px;
        }

        #dateContainer{
            white-space:nowrap;
            /*height:50px;*/
            text-align:center;
            /*line-height: 50px;*/
            /*display: block;*/

            background-color: rgba(255, 255, 255, 0.3);
            font-size: 14px;
            border-radius: 10px;
            border-color: rgb(70, 70, 70);
            border-style: solid;
            border-width: 2px;

            margin-left: auto;
            margin-right: 10px;
            
            padding: 10px;
            padding-top: 15px;
            padding-bottom: 15px;
        }

        #month{
            width: 30px;
            display: inline-block;
        }

        path {
            stroke: rgb(200, 200, 200);
            stroke-width: 0.5px;
        }

        .circles{
            stroke: blue;
            fill: transparent; 
            stroke-width: 2px;
        }

        .show_pa{
            text-align: center;
        }

    </style>
    <script src="https://d3js.org/d3.v4.min.js"> </script>
    <script src="//d3js.org/topojson.v1.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body>
    <div id='container'>
        <div id='infoContainer'>
            <div id='infocell-header'>
                <span id='filter-header'></span>
                <span id='dateContainer'>
                    <span id='month'></span>
                    <span id='year'></span>
                </span>
            </div>
        </div>
        <div id='mapContainer'>
            
        </div>
    </div>
</body>
<script type="text/javascript">

    // ___________________________________________ GLOBAL VARIABLES ___________________________________________


    const MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const PATH_TO_MAP = './data/countries.geo.json';
    const STEP_SIZE = 40; // represents the speed of the slider
    const START_DATE = new Date("1975-01-01");
    const END_DATE = new Date("2016-12-01");
    let current_date = START_DATE;
    let mapContainer = d3.select("#mapContainer");
    let infoContainer = d3.select('#infoContainer');
    let countries;
    let conflicts = {}; // all conflicts, sorted by location id
    let conflicts_by_id = {}; // all conflicts, sorted by conflict id
    let agreements_by_loc = {};
    let agreements_by_id = {};
    let width = mapContainer.node().clientWidth;
    let height = mapContainer.node().clientHeight;
    let margin = 8;
    let selected_country_id = null;

    //colors
    const ACTIVE_PA_COLOR = 'rgb(0, 0, 255)';
    const BROKEN_PA_COLOR = 'rgb(255, 0, 0)';
    const CELL_BORDER_COLOR = 'rgb(70, 70, 70)';


    // ___________________________________________ DOM ELEMENTS ___________________________________________


    infoContainer.style('height', height-margin*2+'px');

    // add infocell header
    infoContainer
    .select('#filter-header')
        .html(d => infoHeaderToString())
        .style('opacity', 0)
        .transition()
        .style('opacity', 1);

    ;


    // ___________________________________________ IMPORT DATA ___________________________________________

    // Conflicts data
    d3.tsv("./data/conflicts.csv")
    .row(function(d) {
        var startdatesplit = d.startdate.split('-');
        var startdate = new Date(parseInt(startdatesplit[0]), parseInt(startdatesplit[1])-1, parseInt(startdatesplit[2]));
        var enddatesplit = d.enddate.split('-');
        var enddate = new Date(parseInt(enddatesplit[0]), parseInt(enddatesplit[1])-1, parseInt(enddatesplit[2]));
        // split locations, in case there are several locations for a single conflict
        d.locationID.split(',').forEach(function(loc_id){
            // create the dict entry if it does not exist yet
            if(!conflicts[loc_id]) conflicts[loc_id] = [];
            // push the data in the dict
            conflicts[loc_id].push({'start':startdate, 'end':enddate, 'locations':d.location, 'conflict_id':d.conflictid, 'sidea':d.sidea, 'sideb':d.sideb});
        });

        conflicts_by_id[d.conflictid] = {'locations':d.location, 'sidea':d.sidea, 'sideb':d.sideb, 'start':startdate, 'end':enddate};
    })
    .get(function(err, rows) {
        if (err) return console.error(err);
    });

    // Peace Agreements data
    d3.tsv("./data/peace_agreements.csv")
        .row(function(row){
            var startdatesplit = row.pa_date.split('-');
            var startdate = new Date(parseInt(startdatesplit[0]), parseInt(startdatesplit[1])-1, parseInt(startdatesplit[2]));
            var enddatesplit = row.enddate.split('-');
            var enddate = new Date(parseInt(enddatesplit[0]), parseInt(enddatesplit[1])-1, parseInt(enddatesplit[2]));
            // store PAs by PAIDs
            agreements_by_id[row.PAID] = {'name':row.pa_name, 'start':startdate, 'end':enddate, 'comment':row.pa_comment, 'end_comment':row.c_duration, 'link':row.link, 'locationID':row.locationID, 'cid':row.CID};
            // store PAIDs by location
            row.locationID.split(',').forEach(function(loc_id){
                // create the dict entry if it does not exist yet
                if(!agreements_by_loc[loc_id]) agreements_by_loc[loc_id] = [];
                // push the data in the dict
                agreements_by_loc[loc_id].push(row.PAID);
            });
            // store an array of its PAIDs in each conflict
            if(!conflicts_by_id[row.CID]['PAIDs']) conflicts_by_id[row.CID]['PAIDs'] = [];
            conflicts_by_id[row.CID]['PAIDs'].push(row.PAID);

        })
        .get(function(err, rows) {
            if (err) return console.error(err);
        });


    // ___________________________________________ MAP DISPLAY ___________________________________________


    let svg = mapContainer.append('svg')
        .attr('width', width)
        .attr('height', height)
        .on('click', function(d){
            selected_country_id = null;
            updateMapAndInfo();
            updateInfoHeader();
        });

    let mapLayer = svg.append('g');

    // projection of the world map
    var projection = d3.geoMercator().scale(width / 2 / Math.PI).translate([width/2, height/2+140]);

    let path = d3.geoPath().projection(projection);

    let centroids = {};
    
    d3.json(PATH_TO_MAP, function(err, geojson) {

        countries = mapLayer.selectAll("path")
        .data(geojson.features)
        .enter().append("path")
        .attr("d", path)
        .attr('id', country => country.id)
        .on('mouseover', function(d,i){
            d3.select(this).style('stroke', 'rgb(255, 255, 255)');
            d3.select(this).style('stroke-width', 2);
        })
        .on('mouseout', function(d, i){
            d3.select(this).style('stroke', 'rgb(200, 200, 200)');
            d3.select(this).style('stroke-width', 0.5);
        })
        .on('click', function(d){
            selected_country_id = d.id;
            updateMapAndInfo();
            updateInfoHeader(d.properties.name);
            d3.event.stopPropagation();
        })
        .append('svg:title').text(function(d, i){return d.properties.name});

        var features = geojson.features;
        features.map(function(f){
            return {'path':path.centroid(f), 'id':f.id};
        }).forEach(c => centroids[c.id] = c.path);
    });



    // ___________________________________________ UPDATE MAP ___________________________________________


    svg.node().addEventListener("mousewheel", function(e){
        onScrollEvent(e.wheelDelta < 0)
    }, false);


    // This function is called at each mouseWheelEvent
    // direction: true if scroll forward, false if backwards
    function onScrollEvent(direction){
        // update the current date
        updateDate(direction);
        printDate(current_date);
        // update the countries' colors
        updateMapAndInfo();
    }

    // updates the respective color of each country on the map
    // and the info panel on the right
    function updateMapAndInfo(){
        let ongoingConflits = new Set();
        let locsWithPA = new Set();
        Object.keys(conflicts).forEach(function(loc_id){
            let status = getConflictStatus(current_date, loc_id);
            let color = getColor(status.status, status.duration);
            // fill the country with the appropriate color
            mapLayer.select('path#'+loc_id).style('fill', color);
            // Fill the array of ongoing conflicts for the info pannel
            if(selected_country_id == null || loc_id == selected_country_id){
                status.ongoingConflits.forEach(conflict => ongoingConflits.add(conflict));
            }
            // Store each location that has at least one active PA
            if(agreements_by_loc[loc_id]){
                agreementStatus = getAgreementsStatus(current_date, loc_id);
                if(agreementStatus.ongoingPA){
                    locsWithPA.add(loc_id);
                }

            }
        });   
        updateInfoPanel(Array.from(ongoingConflits));
        updateInfocells();
        updateCircles(locsWithPA);
        updateAgreementsBorders();
    }


    // draw a blue circle at the centroid of each location in the input array
    // the array contains all the locations that have at least one active PA
    // remove circles from other locations
    function updateCircles(locsWithPA){
        let circles = svg.selectAll('.circles').data(Array.from(locsWithPA), x => x);
        circles.enter()
            .append('circle')
            .classed('circles', true)
            .attr('cx', x => centroids[x][0])
            .attr('cy', x => centroids[x][1])
            //.attr('fill', 'blue')
            .attr('id', x => 'circle_' + x)
            .attr('r', 0)
            .transition()
            .attr('r', 6)
            .transition()
            .attr('r', 3);

        circles.exit()
            .attr('r', 3)
            .transition()
            .attr('r', 0)
            .remove();
    }
    // ___________________________________________ INFO PANEL ___________________________________________


    // This method is called on each scroll event to append new conficts 
    // and remove finished conflicts
    function updateInfoPanel(conflict_ids){

        let cells = d3.select('div#infoContainer').selectAll('.infocell').data(conflict_ids, cft_id => cft_id);
        
        cells.exit()
            .remove();
        
        cells.enter()
            .append('div')
            .classed('infocell', true)
            .attr('id', cid => 'infocell_' + cid)
            .attr('cid', cid => cid)
            .attr('open', '0')
            .on('click', function(d){showHideAgreements(d)})
            .on('mouseover', function(d){
                d3.select(this).style('border-color', CELL_BORDER_COLOR);
                if(hasAgreements(d)) d3.select(this).select('.show_pa').select('i').style('opacity', '1');
            })
            .on('mouseout', function(d){
                d3.select(this).style('border-color', 'transparent');
                d3.select(this).select('.show_pa').select('i').style('opacity', '0.5');
            })
            .html(cid => conflictToString(cid) + closedAgreementToString(hasAgreements(cid)))
            .style('opacity', 0)
            .transition()
            .style('opacity', 1);
    }

    // this function is called when a conflict cell in the infopanel is clicked
    // it shows/hides the 
    function showHideAgreements(cid){
        if(!conflicts_by_id[cid].PAIDs){
            console.log("no PAs")
            return;
        }
        let cell = d3.select('#infocell_'+cid);
        if(cell.attr('open') == '0'){
            cell.attr('open', '1')
            .append('div')
                .attr('class', 'pas_container')
                .html(agreementToString(cid))
                .style('opacity', 0)
                .transition()
                .style('opacity', 1);
            cell.select('.show_pa').remove();
            cell.append('div').html("<div class=show_pa><i style='opacity:0.5'>Click on the cell to hide the peace agreements ...</i></div>");
        }
        else{
            cell.attr('open', '0')
                .select('.pas_container')
                .remove();
            cell.select('.show_pa').remove();
            cell.append('div').html(closedAgreementToString(true));
        }

    }

    // returns a string decribing the conflict for the infopanel
    function conflictToString(c_id){
        let c = conflicts_by_id[c_id];
        let res = "";
        let pas_sums = getAgreementsSums(c_id, current_date);
        res += "<div style='text-align:center'><i style='opacity:0.5'>Conflict #" + c_id + "</i></div>";
        // active/broken PAs count
        if(pas_sums){
            res += "<span class='pa_sums'>";
            res += paSumsToString(pas_sums);
            res += "</span>";
        }
        res += "Location: " + c.locations;
        res += "<br/>Duration: " + dateToString(c.start) + " - " + dateToString(c.end);
        res += "<br/>Side A: " + c.sidea + "<br/>Side B: " + c.sideb;
        return res;
    }

    // returns html code that contains info about how many PAs are active/broken
    function paSumsToString(pa_sums){
        let res = "<div> Active/Broken peace agreements: ";
        for(let i = 0; i < pa_sums.active; i++){
            res += '<i class="test fa fa-check-circle-o" aria-hidden="true" style="text-weight:bold; padding-left: 3px;font-size:16px; color:'+ ACTIVE_PA_COLOR +'"></i>';
        }
        for(let i = 0; i < pa_sums.broken; i++){
            res += '<i class="test fa fa-times-circle-o" aria-hidden="true" style="text-weight:bold; padding-left: 3px;font-size:16px; color:'+ BROKEN_PA_COLOR +'"></i>';
        } 
        res += "</div>";
        return res;

    }

    // returns html code containing 'show more' message
    function closedAgreementToString(has_pas){
        return has_pas ? ("<div class=show_pa><i style='opacity:0.5'>Click on the cell to see the peace agreements ...</i></div>") : ("<div class=show_pa><i style='opacity:0.5'>No peace agreement for this conflict</i></div>");
    }

    // if cid has PAs, returns the list of its PAIDs, false otherwise
    function hasAgreements(cid){
        return conflicts_by_id[cid].PAIDs;
    }

    
    // returns html element containing textual representation of all the PAs relative to the input conflict
    function agreementToString(cid){
        let result = "";

        let paids = conflicts_by_id[cid].PAIDs;
        if(!paids) return result;
        paids.forEach(function(paid){
            let pa = agreements_by_id[paid];
            let color = getAgreementColor(pa);
            result += "<div class='cell_pa' paid='" + paid + "' style='border-color:" + color + "'>";
            result += "<div style='text-align:center'><strong><i style='opacity:1'>" + pa.name + "</i></strong></div>" 
            result += "<br/>Duration: " + dateToString(pa.start) + " - " + dateToString(pa.end);
            result += "<br/><br/><div style='white-space: pre-line'>" + pa.comment + "</div>";
            result += "</div>";
        });

        return result;
    }

    // selects the open conflict cells and updates the color of the PA cells at each time change
    function updateAgreementsBorders(){
        let cells = d3.selectAll('.infocell').filter(function(d){return d3.select(this).attr('open') == '1';}).selectAll('.cell_pa');
        cells.each(function(d){
            let cell = d3.select(this);
            //let previous_color = cell.style('border-color');
            let color = getAgreementColor(agreements_by_id[cell.attr('paid')]);
            cell.style('border-color', color);
            /*if(previous_color != color){
                // laggy transitions
                //cell.style('border-color', color).transition().duration(100).style('border-color', 'transparent').transition().duration(100).style('border-color', color);
                cell.style('border-color', color);
            }*/
        });
    }

    // updates in each infocell the number of active/broken PAs
    function updateInfocells(){
        infoContainer.selectAll('.infocell').each(function(d){
            let cell = d3.select(this);
            let cid = cell.attr('cid');
            let pa_sums = getAgreementsSums(cid, current_date);
            cell.select('.pa_sums').html(paSumsToString(pa_sums));
        });
    }

    // returns html code to fill the header of the infocells
    function infoHeaderToString(locationName=null){
        let res;
        if(locationName){
            let locName = locationName.length > 15 ? selected_country_id : locationName;
            res = "Ongoing conflicts in <strong>" + locName + "</strong>";
        }
        else{
            res = '<i style="opacity:0.5;">Click on any country to select it</i>';
        }

        return res;
    }

    function updateInfoHeader(locationName=null){
        infoContainer.select('#filter-header').html(infoHeaderToString(locationName));
    }


    // ___________________________________________ DATE PANEL ___________________________________________


    function dateToString(date){
        return date.getFullYear() == 2099 ? 'today' : MONTH_NAMES[date.getMonth()] + " " + date.getFullYear();
    }

    // prints the input date in the date container
    function printDate(date){
        d3.select('#month').html(MONTH_NAMES[date.getMonth()]);
        d3.select('#year').html(date.getFullYear());
    }

    // This void function updates the global 'current_date' variable after a scrollEvent
    // direction: the scroll direction that defines if we go back or forward in time
    function updateDate(direction){
        // are we scrolling up or down?
        let step = direction ? STEP_SIZE : -STEP_SIZE;
        let new_date = d3.timeDay.offset(current_date, step);

        // clamp the date
        if(new_date < START_DATE){
            current_date = START_DATE;
        }
        else if(new_date > END_DATE){
            current_date = END_DATE;
        }
        else{
            current_date = new_date;
        }
    }


    // ___________________________________________ HELPER METHODS ___________________________________________


    // returns true if there is at least one conflict in the country, false otherwise
    function isInConflict(date, country){
        return conflicts[country].some(conflict => (date > conflict.start && date < conflict.end));
    }

    // input: a duration in ms
    // output: the same duration in days
    function msToDays(ms){
        return Math.round(ms/(1000*60*60*24));
    }

    // This function returns the status of the country at the given date
    // and for how long this status has been lasting
    // it also returns an array containing the ongoing conflicts
    // true: conflict, false: no conflict (i.e. peace)
    // country: country id
    function getConflictStatus(current_date, country){
        let ongoingConflits = conflicts[country].filter(c => (current_date > c.start && current_date < c.end));
        let status, duration;

        // The country is at peace
        if(ongoingConflits.length == 0){
            status = false;
            let latestPeaceDay = d3.max([START_DATE, d3.max(conflicts[country].map(c => c.end).filter(end => end < current_date))]);
            duration = msToDays(current_date - latestPeaceDay);
        }
        // Only one conflict in the country at that time
        else if(ongoingConflits.length == 1){
            status = true;
            duration = msToDays(current_date - ongoingConflits[0].start);
        }
        // more than one conflict at that time
        else{
            status = true;
            duration = msToDays(current_date - d3.min(ongoingConflits, c => c.start));
        }
        return {'status': status, 'duration':duration, 'ongoingConflits':ongoingConflits.map(c => c.conflict_id)};
    }

    function getAgreementsStatus(current_date, country_id){
        let ongoingPas = agreements_by_loc[country_id].map(paid => agreements_by_id[paid]).filter(pa => (current_date >= pa.start && current_date < pa.end));
        let brokenPas = agreements_by_loc[country_id].map(paid => agreements_by_id[paid]).filter(pa => (current_date >= pa.start && current_date >= pa.end));
        return {'ongoingPA':(ongoingPas.length > 0), 'brokenPA':(brokenPas.length > 0), 'ongoingPas':ongoingPas, 'brokenPas':brokenPas};
    }

    // returns the number of active/broken agreements of the input conflict at the input date
    function getAgreementsSums(cid, date){
        if(!hasAgreements(cid)) return false;
        let activePas = conflicts_by_id[cid].PAIDs.map(paid => agreements_by_id[paid]).filter(pa => (current_date >= pa.start && current_date < pa.end));
        let brokenPas = conflicts_by_id[cid].PAIDs.map(paid => agreements_by_id[paid]).filter(pa => (current_date >= pa.start && current_date >= pa.end));
        return {'active':activePas.length, 'broken':brokenPas.length};
    }

    function getAgreementColor(pa){
        if(pa.start > current_date) return 'transparent';
        else if(pa.end <= current_date) return BROKEN_PA_COLOR;
        else if(pa.start <= current_date && pa.end > current_date) return ACTIVE_PA_COLOR;
        else{
            console.error('Agreement color error, this should not happen');
            return 'transparent';
        }
    }

    // returns the corresponding color (red for conflict, green for peace)
    // the duration determines the intensity (saturation) of the color
    // status: boolean indicating wether there is a conflict of not
    // duration: for how long has this status been lasting?
    function getColor(status, duration){
        let hue = status ? 360 : 100;
        let scale = d3.scaleLinear().domain([0, 5000]).range([0.3, 1]).clamp(true);
        let saturation = scale(duration);

        let color = d3.hsl(hue, saturation, 0.5);
        return color.rgb();
    }

</script>
</html>